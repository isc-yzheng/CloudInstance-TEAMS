Include (HS.HC, HS.IHE.PIX, HS.IHE.ATNA)

Class HS.IHE.PIX.Manager.Process Extends (Ens.BusinessProcess, HS.HC.Util.Trace.Helper) [ ClassType = persistent, Inheritance = right ]
{

Parameter HSDEPLOY = 1;

/*
/// Device Sender is the facility must be defined

Custodian
Registration event

*/
Parameter SETTINGS = "MPIOperations,IHEVersion,DeviceID,PIXv2Operations,PIXv3Operations,AffinityDomain,AffinityDomainIsMPIID,HUB,TransformPIXToPatientSearch,NotifyWithDemographics,ApplyConsent,ExcludeIdentifierTypes,MatchCodeWithOID";

/// Config Item where the Add/Update Operations will be sent 
Property MPIOperations As Ens.DataType.ConfigName [ InitialExpression = "HS.Hub.MPI.Manager" ];

/// Used when dynamic registration is enabled.
Property HUB As Ens.DataType.ConfigName [ InitialExpression = "HS.Hub.Management.Operations" ];

/// Used in a testing environment allows setting of the AffinityDomain Code (which must be defined in the OID Registry) if not
/// set the value from ##class(HS.IHE.Util).GetAffinityDomain() is used
Property AffinityDomain As %String;

/// Used to determine whether AffinityDomain is the MPIID (true - general scenario) or whether the MPIID is in the results (typically IHE testing)
Property AffinityDomainIsMPIID As %Boolean [ InitialExpression = 1 ];

/// If true, patient search requests generated by this process will be processed by consent.
Property ApplyConsent As %Boolean [ InitialExpression = 0 ];

Property PIXv2Operations As Ens.DataType.ConfigName [ InitialExpression = "PIXv2.Notification.Operations" ];

Property PIXv3Operations As Ens.DataType.ConfigName [ InitialExpression = "PIXv3.Notification.Operations" ];

Property IHEVersion As %Integer [ InitialExpression = 1 ];

Property IHEExtension As %String;

Property Transformer As HS.Util.XSLTTransformer;

/// PIXQuery to PatientSearchRequest (201309)
Property TransformPIXToPatientSearch As %String(MAXLEN = "") [ InitialExpression = "IHE/PIX/Version1/PRPAIN201309UVToPatientSearchRequest.xsl" ];

Property TransformMatchToUpdateNotification As %String(MAXLEN = "") [ InitialExpression = "IHE/PIX/Version1/PatientSearchMatchToPRPAIN201302UV.xsl" ];

Property TransformPIXToAddUpdateHubRequest As %String(MAXLEN = "") [ InitialExpression = "IHE/PIX/Version1/PRPAIN201301UVToAddUpdateHubRequest.xsl" ];

Property TransformToMCCI As %String(MAXLEN = "") [ InitialExpression = "IHE/PIX/Version1/MCCI000002UV.xsl" ];

Property TransformPatientSearchResponseToPIX As %String(MAXLEN = "") [ InitialExpression = "IHE/PIX/Version1/PatientSearchResponseToPRPAIN201310UV.xsl" ];

Property TransformPIXToMergePatientRequest As %String(MAXLEN = "") [ InitialExpression = "IHE/PIX/Version1/PRPAIN201304UVToMergePatientRequest.xsl" ];

/// Used as the sender or receiver device ID - PIXv3 only
Property DeviceID As %String;

/// When the identifier type is unknown, a lookup is done against in HS_AssignAuth.Config for the Code (AssigningAuthority Code),<br>
/// looking for a single type.  If a code is used for multiple types, it is possible to exclude specific types using a comma delimited<br>
/// list so that a single value is identified.
Property ExcludeIdentifierTypes As %String [ InitialExpression = "DL,DN" ];

Property Errors As HS.Types.IHE.Errors;

Property NotifyWithDemographics As %Boolean [ InitialExpression = 0 ];

/// Applies to HL7 PIXv2 only. When this is checked (true), if an ISO-formatted assigning
/// authority or facility in an incoming HL7 message includes both a code (NamespaceID)
/// and an OID (UniversalID), then the code must match the IdentityCode defined for the
/// OID in the OID Registry. Otherwise, if this setting is not checked and both code and
/// OID are included in the identifier, then OID is considered to be the authoritative
/// value.
Property MatchCodeWithOID As %Boolean [ InitialExpression = 0 ];

Method OnRequest(pRequest As %Library.Persistent, Output pResponse As %Library.Persistent) As %Status
{
	Set tSC=$$$OK
	Set ..IHEExtension=$s(..IHEVersion=1:"02",1:"")
	$$$GetTransformer(..Transformer)
	If ..AffinityDomain="" Set ..AffinityDomain=$$$AffinityDomain
	
	Set ..Errors = ##class(HS.Types.IHE.Errors).%New()
	
	If pRequest.%IsA("HS.Message.IDUpdateNotificationRequest") {
		Set tSC = ..UpdateNotification(pRequest)
	} ElseIf pRequest.%IsA("EnsLib.HL7.Message") {
		Set tSC = ..ProcessHL7Message(pRequest, .pResponse)
	} ElseIf pRequest.%IsA("HS.Message.XMLMessage") {
		Set tSC = ..ProcessXMLMessage(pRequest, .pResponse)
	} Else {
		Set tSC = $$$ERROR($$$GeneralError, "Message class "_pRequest.%ClassName(1)_" not handled")
	}
	
	If ..Errors.Errors.Count() {
		$$$HSTRACE("Errors","Errors",..Errors)
		Set tErrorText="",tWarningText=""
		For tIdx=1:1:..Errors.Errors.Count() {
			Set tError = ..Errors.Errors.GetAt(tIdx)
			If tError.Severity="Error"!(tError.Severity="E")!(tError.Severity="error") {
				Set tErrorText = tErrorText _ "["_tError.Description_ "]"
			} Else {
				Set tWarningText = tWarningText _ "["_tError.Description_ "]"
			}
		}
		If tErrorText]"" $$$LOGERROR(tErrorText)
		If tWarningText]"" $$$LOGWARNING(tWarningText)
	}
	Quit tSC
}

/// OnResponse must be overridden here to avoid error upon response from async request.
Method OnResponse(pRequest As Ens.Request, ByRef pResponse As Ens.Response, pCallrequest As Ens.Request, pCallresponse As Ens.Response, pCompletionKey As %String) As %Status
{
	Quit $$$OK
}

Method ProcessHL7Message(pRequest As EnsLib.HL7.Message, Output pResponse As EnsLib.HL7.Message) As %Status
{
	Set tSC = $$$OK
	
	Try {
		$$$HSTRACE("HL7 Request from service", "pRequest", pRequest.OutputToString())
		
		// Clone pRequest to tHL7Request so that changes are only applied to tHL7Request.
		Set tHL7Request = pRequest.%ConstructClone(1)
		
		Set tMessageCode = $ZConvert(pRequest.GetValueAt("MSH:9.1"), "U")
		Set tTriggerEvent = $ZConvert(pRequest.GetValueAt("MSH:9.2"), "U")
		Set tMessageType = tMessageCode_"^"_tTriggerEvent
		If tMessageType="QBP^Q23" {
			Set tSC=..QueryRequestv2(tHL7Request, .pResponse)
		} ElseIf tMessageType="ADT^A40" {
			Set tSC=..MergePatientv2(tHL7Request, .pResponse)
		} ElseIf tMessageCode="ADT",(tTriggerEvent="A01"!(tTriggerEvent="A04")!(tTriggerEvent="A05")!(tTriggerEvent="A08")) {
			Set tSC=..AddPatientv2(tHL7Request, .pResponse)
		} Else {
			Do ..Errors.logError("200","E","Unsupported HL7 Message Type : "_tMessageType)
		}
		
		If $IsObject(pResponse) {
			Set tEnvelopeFromService = tHL7Request.Envelope
			Set tHL7Request.Envelope = ""
			Set tFromHost = $Piece($Piece(tEnvelopeFromService,"<-",2),":",1)
			Set tEnvelopeToAudit = ""
			Set tEnvelopeToAudit = tEnvelopeToAudit_"|ToHost="_$system.INetInfo.HostNameToAddr($system.INetInfo.LocalHostName())_"|"
			Set tEnvelopeToAudit = tEnvelopeToAudit_"|FromHost="_tFromHost_"|"
			Set tHL7Request.Envelope = tEnvelopeToAudit
			Do $$$ATNAEvent("PIXv2Manager", tHL7Request, pResponse, tSC)
		}
		
		If ..Errors.Errors.Count() Set tSC = ..HL7ErrorResponse(tHL7Request, .pResponse)
		
	} Catch eException {
		Set tSC = eException.AsStatus()
	}
	
	If $Data(pResponse),$IsObject(pResponse) $$$HSTRACE("HL7 Response to service", "pResponse", pResponse.OutputToString())
	
	Quit tSC
}

Method ProcessXMLMessage(pRequest As HS.Message.XMLMessage, Output pResponse As HS.Message.XMLMessage) As %Status
{
	Set tSC = $$$OK
	
	Try {
		$$$HSTRACE("request","pRequest",pRequest)
		
		If pRequest.Name=$$$PIXv3AddRequest {
			Set tSC=..AddPatientv3(pRequest,.pResponse)
			Do $$$ATNAEvent("PIXv3Manager",pRequest,pResponse,tSC)
		} ElseIf pRequest.Name=$$$PIXv3ReviseRequest {
			Set tSC=..RevisedPatient(pRequest,.pResponse)
			Do $$$ATNAEvent("PIXv3Manager",pRequest,pResponse,tSC)
		} ElseIf pRequest.Name=$$$PIXv3QueryRequest {
			Set tSC=..QueryRequestv3(pRequest,.pResponse)
			Do $$$ATNAEvent("PIXv3Manager",pRequest,pResponse,tSC)
		} ElseIf pRequest.Name=$$$PIXv3MergeRequest {
			Set tSC=..MergePatientv3(pRequest,.pResponse)
			Do $$$ATNAEvent("PIXv3Manager",pRequest,pResponse,tSC)
		} Else {
			$$$LOGERROR("Unknown Request")
			Set tSC=$$$ERROR($$$GeneralError,"Unknown request")
		}
		
	} Catch eException {
		Set tSC = eException.AsStatus()
	}
	
	Quit tSC
}

Method AddPatientv2(pHL7Request As EnsLib.HL7.Message, Output pHL7Response As EnsLib.HL7.Message) As %Status
{
	Try {
		Set tSC = ..HL7ToAddOrUpdateRequest(pHL7Request, .tAddRequest)
		If $$$ISERR(tSC) Quit
		If ..Errors.Errors.Count() Quit
		
		Set tSC = ..SendAddPatient(tAddRequest, .tAddResponse, 1)
		If $$$ISERR(tSC) Quit
		If ..Errors.Errors.Count() Quit
		
		Set tSC = ..AddOrUpdateResponseToHL7(tAddResponse, .pHL7Response, pHL7Request)
		If $$$ISERR(tSC) Quit
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

/// new patient, also called by RevisePatient code
Method AddPatientv3(pRequest As HS.Message.XMLMessage, Output pResponse As HS.Message.XMLMessage) As %Status
{
	#dim eException As %Exception.AbstractException
	try {
		Set pResponse=pRequest.%New()
		Set pResponse.Name			= $$$PIXv3AddResponse
		Set pResponse.DocType		= "MCCI_IN000002UV01"

		#dim tAddRequest as HS.Message.AddUpdateHubRequest
		#dim tAddReponse as HS.Message.AddUpdateHubResponse
		Do pRequest.ContentStream.Rewind()
		$$$HSTRACESTARTCALL
		Set tSC = ..Transformer.TransformIntoObject(pRequest.ContentStream,..TransformPIXToAddUpdateHubRequest /*"IHE/PIX/Version1/PRPAIN201301UVToAddUpdateHubRequest.xsl" */,.tAddRequest,.tXSLArguments,"HS.Message.AddUpdateHubRequest","AddUpdateHubRequest")
		$$$HSTRACEENDCALL
		IF $$$ISERR(tSC) || '$isObject(tAddRequest) {
			$$$LOGINFO("Unable to transform request:"_pRequest.ContentStream.Read(320000))
			Do ..Errors.logError("204","Error","Unable to transform request"_$system.Status.GetErrorText(tSC))
			Quit
		}
		#; TransformPIXToAddUpdateHubRequest does not set the Use property on
		#; Identifiers.  Try to derive Use here by looking at the Assigning
		#; Authority Registry.  If the Use cannot be determined then discard
		#; the Identifier.
		For i = tAddRequest.Identifiers.Count():-1:1 {
			Set tRoot = tAddRequest.Identifiers.GetAt(i).Root
			If tRoot=..AffinityDomain Continue
			Set tSC = ##class(HS.IHE.Util).AAIdentifierTypeForCode(tRoot, .tAAIdentifierType,..ExcludeIdentifierTypes)
			If $$$ISERR(tSC)!(tAAIdentifierType="") {
				$$$LOGINFO("Unable to determine Use for Identifier.Root="_tRoot_" - removed Identifier")
				Do tAddRequest.Identifiers.RemoveAt(i)
			} Else {
				Set tAddRequest.Identifiers.GetAt(i).Use = tAAIdentifierType
			}
		}
	 	$$$HSTRACE("Add Request with Identifier updates","tAddRequest",tAddRequest)
	 	
		Set tSC = ##class(HS.Types.RequestInfo).XMLMessageToRequestInfo(pRequest, tAddRequest)
		
		Set tSC = ..SendAddPatient(tAddRequest, .tAddResponse)
		If $$$ISERR(tSC) Quit
		
		If $Data(tAddResponse),$IsObject(tAddResponse),$$$ISOK(tAddResponse.ErrStatus),tAddResponse.MPIID'="" Do pResponse.AdditionalInfo.SetAt(tAddResponse.MPIID_"^^^&"_$$$HomeCommunityOID_"&ISO","PatientId")
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		$$$LOGERROR(eException.DisplayString())
		Do ..Errors.logError("204","Error","Internal Error:"_$system.Status.GetErrorText(tSC))
	}
	Try {
		Set tOutput = ##class(%Stream.GlobalCharacter).%New()
		Do tOutput.Write("<root>")
		Do tOutput.Write("<originalRequest>")
		Do tOutput.CopyFrom(pRequest.ContentStream)
		Do tOutput.Write("</originalRequest>")
		Do ..Errors.XMLExportToString(.tErrorString)
		Do tOutput.Write(tErrorString) 
		Do tOutput.Write("</root>")
		Do tOutput.Rewind()

		$$$HSTRACE("Error Count "_..Errors.Errors.Count(),"toutput",tOutput)
		Set tXSLArguments("messageID") = $System.Util.CreateGUID()
		Set tXSLArguments("creationTime") = ##class(HS.Util.XSLTHelper).timestamp()
		Set tXSLArguments("typeCode") = $S(..Errors.Errors.Count():"CE",1:"CA")  
		#; stream as input is any stream, it's not used in the transformation
		$$$HSTRACESTARTCALL
		Set tSC = ..Transformer.Transform(tOutput,..TransformToMCCI /*"IHE/PIX/Version1/MCCI000002UV.xsl" */,.tTarget,.tXSLArguments)
		$$$HSTRACEENDCALL
		$$$HSTRACE("Response Transformer Status","tSC",tSC)
		If $$$ISOK(tSC) Set pResponse.ContentStream	= tTarget
	
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("204","Error","Internal Error:"_$system.Status.GetErrorText(tSC))
	}
	Quit tSC
}

/// SendAddPatient is called by AddPatientv2 and AddPatientv3.  It sends
/// AddUpdateHubRequest to the MPIOperations and does other logic that
/// is common to v2 and v3.
/// Input parameter pv2 indicates that this method is being called as part
/// of a PIXv2 AddPatient.  It is used for logging to ..Errors.  For
/// AddPatient, the contents of the request have already been validated by
/// HL7ToAddPatientRequest.  So pv2 is used here only post-query.
Method SendAddPatient(pAddRequest As HS.Message.AddUpdateHubRequest, Output pAddResponse As HS.Message.AddUpdateHubResponse, pv2 As %Boolean = 0) As %Status
{
	#dim eException As %Exception.AbstractException
	
	Set tSC = $$$OK
	
	try {
		Set tSeverityError = $Select(pv2=1:"E",1:"Error")
		
		If pAddRequest.AssigningAuthority="" Do ..Errors.logError("204","Error","Patient id missing assigning authority","/hl7:controlActProcess/hl7:subject/hl7:registrationEvent/hl7:subject1/hl7:patient/hl7:id") Quit
		
		If ##class(HS.Data.OIDMap).GetOIDForCode(pAddRequest.AssigningAuthority,"")="" {
			#; if the code doesn't exist pAddRequest.AssigningAuthority = "Unknown OID for "_the original oid
			Do ..Errors.logError("204","Error","Patient id unknown assigning authority OID: "_pAddRequest.AssigningAuthority,"/hl7:controlActProcess/hl7:subject/hl7:registrationEvent/hl7:subject1/hl7:patient/hl7:id") Quit
		}
		
		#dim tControlledID As HS.Types.Identifier
		
		For tIdx = pAddRequest.Identifiers.Count():-1:1 {
			Set tControlledID = pAddRequest.Identifiers.GetAt(tIdx)
			If tControlledID.Root=..AffinityDomain {
				Set pAddRequest.MPIID=tControlledID.Extension
				Do pAddRequest.Identifiers.RemoveAt(tIdx)
				Continue
			}
			If ##class(HS.Data.OIDMap).GetOIDForCode(tControlledID.Root,"")="" {
				Set:tControlledID.Root=$c(0) tControlledID.Root="empty string"
				If $$$ISERR(tSC) Do ..Errors.logError("204","Error","Unknown assigning authority in asOtherIDs ("_tIdx_") "_tControlledID.Root)
			}	
			If tControlledID.Extension="" Do ..Errors.logError("204","Error","Empty extension in asOtherIDs ("_tIdx_")")
		}
		
		Set tFacility=pAddRequest.Facility
		//Connectathon Set:tFacility="" tFacility="IHEFACILITY",pAddRequest.Facility=tFacility
		If tFacility]"" && ##class(HS.Facility.Config).%ExistsId(tFacility) {
			//Set tAddRequest.Facility=tFacility
			Set tFacilityObject=##class(HS.Facility.Config).%OpenId(tFacility)
			If $isObject(tFacilityObject) {
				Set pAddRequest.GatewayName=tFacilityObject.Gateway.Name
			}
		} Else {
			Do ..Errors.logError("204","Error","Provider organization is unknown but is required:"_tFacility_". Please add to the Facility Registry")
		}
		If (pAddRequest.MRN = "") Do ..Errors.logError("204","Error", "Unable to retrieve patient ID from source PRPA_IN1201301 message")

		$$$HSTRACE("Sending message to MPIOperations","pAddRequest",pAddRequest)
		$$$HSTRACE("AffinityDomain versus AA","AffinityDomain,AssigningAuthority",..AffinityDomain,pAddRequest.AssigningAuthority)
		If pAddRequest.AssigningAuthority=..AffinityDomain Set pAddRequest.MPIID=pAddRequest.MRN
		If '..Errors.Errors.Count() {
			Set tSC=..SendRequestSync(..MPIOperations,pAddRequest,.pAddResponse)
			If $$$ISERR(tSC) Do ..Errors.logError("204",tSeverityError,"Error updating MPI "_$system.Status.GetErrorText(tSC))
			If $$$ISERR(pAddResponse.ErrStatus) Do ..Errors.logError("204",tSeverityError,"Error updating MPI "_$system.Status.GetErrorText(pAddResponse.ErrStatus))
		}
	} Catch eException {
		Set tSC = eException.AsStatus()
		$$$LOGERROR(eException.DisplayString())
		Do ..Errors.logError("204",$Get(tSeverityError),"Internal Error:"_$system.Status.GetErrorText(tSC))
	}

	Quit tSC
}

/// call addpatient for revise
Method RevisedPatient(pRequest As HS.Message.XMLMessage, Output pResponse As HS.Message.XMLMessage) As %Status
{
	Quit ..AddPatientv3(pRequest,.pResponse)
}

/// QueryRequestv2 takes the HL7 QBP^Q23 and returns the HL7 RSP^K23.
Method QueryRequestv2(pHL7Request As EnsLib.HL7.Message, Output pHL7Response As EnsLib.HL7.Message) As %Status
{
	Set tSC = $$$OK
	
	Try {
		Set tSC = ..HL7ToPatientSearchRequest(pHL7Request, .tSearchRequest)
		If $$$ISERR(tSC) Quit
		If ..Errors.Errors.Count() Quit
		
		Set tSC = ..SendAndFilter(tSearchRequest, .tFilteredResponse, "v2")
		If $$$ISERR(tSC) Quit
		If ..Errors.Errors.Count() Quit
		
		Set tSC = ..PatientSearchResponseToHL7(tFilteredResponse, .pHL7Response, pHL7Request)
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

/// Take 201309 request run query and return 201310
Method QueryRequestv3(pRequest As HS.Message.XMLMessage, Output pResponse As HS.Message.XMLMessage) As %Status
{
	#dim eException As %Exception.AbstractException
	#dim tFilteredResponse As HS.Message.PatientSearchResponse
	
	Set tSC = $$$OK
	
	try {
		Set pResponse=pRequest.%New()
		Set pResponse.Name			= $$$PIXv3QueryResponse
		Set pResponse.DocType		= ""
		
		
		Do ##class(HS.Types.RequestInfo).GetUserInfo(pRequest, .tUserName, .tUserRoles)  ///SAML/User Auth
		Set tXSLArguments("userName")		=  $ZCVT(tUserName,"O","XML")
		Set tXSLArguments("userRoles")		=  tUserRoles
		Set tXSLArguments("gatewayName")	=  $namespace

		$$$HSTRACESTARTCALL
		Set tSC = ..Transformer.TransformIntoObject(pRequest.ContentStream,..TransformPIXToPatientSearch /*"IHE/PIX/Version1/PRPAIN201309UVToPatientSearchRequest.xsl" */, .tSearchRequest, .tXSLArguments, "HS.Message.PatientSearchRequest","PatientSearchRequest")
		$$$HSTRACEENDCALL
		If $$$ISERR(tSC) {
			Do ..Errors.logError("204","Error","Unable to transform original request "_$system.Status.GetErrorText(tSC))
			Quit
		}
		Set:..ApplyConsent tSearchRequest.SearchMode="PIXPDQ_c"
		Do pRequest.ContentStream.Rewind()
		Set tSC = ##class(HS.Types.RequestInfo).XMLMessageToRequestInfo(pRequest, tSearchRequest) ///SAML/User Auth -- probably already done by XSLT above but just in case
		If $$$ISERR(tSC) Do ..Errors.logError("204","Error","Error setting request information "_$system.Status.GetErrorText(tSC)) Quit

		Set tSC = ..SendAndFilter(tSearchRequest,.tFilteredResponse,"v3")
		If $$$ISERR(tSC) Do ..Errors.logError("204","Error","Error executing MPI Search "_$system.Status.GetErrorText(tSC)) Quit

	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("204","Error","Internal Error:"_$system.Status.GetErrorText(tSC))
	}
	Try {
		Set tSearchStatus=tSC
		If '$isObject(tSearchRequest) Set tSearchRequest = ##class(HS.Message.XMLMessage).%New()
		Set tSC = tFilteredResponse.XMLExportToStream(.tSearchResponseStream) Quit:$$$ISERR(tSC)
		Set tOutput = ##class(%Stream.GlobalCharacter).%New()
		Do tOutput.Write("<root>")
		While 'tSearchResponseStream.AtEnd {
			Do tOutput.Write(tSearchResponseStream.Read())
		}
		Do ..Errors.XMLExportToString(.tErrorString)
		Do tOutput.Write(tErrorString)
		Do tOutput.Write("<originalRequest>")
		Do pRequest.ContentStream.Rewind()
		While 'pRequest.ContentStream.AtEnd {
			Do tOutput.Write(pRequest.ContentStream.Read())
		}
		Do tOutput.Write("</originalRequest></root>")
		Do tOutput.Rewind()
		$$$HSTRACE("ResponseStream","tSearchResponseStream",tOutput) Do tOutput.Rewind()
		Set tXSLArguments=""
		Set tXSLArguments("messageID") = $System.Util.CreateGUID()
		Set tXSLArguments("creationTime") = ##class(HS.Util.XSLTHelper).timestamp()
		Set tXSLArguments("queryStatus") = $S($$$ISERR(tSearchStatus):"AE",..Errors.Errors.Count():"AE",tFilteredResponse.Results.Count()=0:"NF",1:"OK")
		$$$HSTRACE("query status","querystatus",tXSLArguments("queryStatus"))
		If ..AffinityDomain]"" {
			Set tDescription = $tr(##class(HS.Data.OIDMap).OIDDescription($$$AffinityDomainOID),$c(0))
			Set:tDescription="" tDescription = ..AffinityDomain
			Set tXSLArguments("custodian") = ..AffinityDomain
			Set tXSLArguments("custodianName") = $ZCVT(tDescription,"O","XML")
		}
		Set tXSLArguments("ackTypeCode") = $S($$$ISERR(tSearchStatus):"AE",..Errors.Errors.Count():"AE",1:"AA")  /// this needs to be AE if the patient id is not known versus not found / filtered by response
		$$$HSTRACESTARTCALL
		Set tSC = ..Transformer.Transform(tOutput,..TransformPatientSearchResponseToPIX /*"IHE/PIX/Version1/PatientSearchResponseToPRPAIN201310UV.xsl"*/,.tRegistryResponse,.tXSLArguments)
		$$$HSTRACEENDCALL
		If $$$ISERR(tSC) Do ..Errors.logError(204,"Error","Internal Error"_$system.Status.GetErrorText(tSC)) Quit
		Do tRegistryResponse.Rewind()

		Set pResponse=pRequest.%New()
		Set pResponse.Name			= $$$PIXv3QueryResponse
		Set pResponse.DocType		= "PRPA_IN201310UV"_..IHEExtension
		Set pResponse.ContentStream=tRegistryResponse
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("204","Error","Internal Error:"_$system.Status.GetErrorText(tSC))
	}
	Quit tSC
}

/// SendAndFilter is called by QueryRequestv2 and QueryRequestv3.
/// It sends the PatientSearchRequest to the MPIOperations config
/// item, gets the response, and applies domain filters as needed.
/// Input parameter pMsgFormat indicates the message format
/// (v2, v3) for the current Query request.  It is used for
/// determining what kind of data to log to ..Errors.
Method SendAndFilter(pSearchRequest As HS.Message.PatientSearchRequest, pFilteredSearchResponse As HS.Message.PatientSearchResponse, pMsgFormat As %String = "v3") As %Status
{
	#dim eException As %Exception.AbstractException
	
	Set tSC = $$$OK
	
	Set pFilteredSearchResponse = ##class(HS.Message.PatientSearchResponse).%New()
	try {
		If (pMsgFormat'="v2")&&(pMsgFormat'="v3") Set tSC = $$$ERROR($$$GeneralError, "Invalid message format parameter") Quit
		
		Set tSeverityError = $Case(pMsgFormat, "v2":"E", "v3":"Error", :"Error")

		Set tSearchAA=pSearchRequest.AssigningAuthority
		If tSearchAA]"" {
			Set tSearchAAOID=##class(HS.Data.OIDMap).GetOIDForCode(tSearchAA,"")
			If tSearchAAOID="" {
				Set tErr = "Unable to find specified Assigning Authority "_tSearchAA
				If pMsgFormat="v2" {
					Do ..Errors.logError("204", tSeverityError, tErr, "QPD:3.4")
				} ElseIf pMsgFormat="v3" {
					Do ..Errors.logError("204", tSeverityError, tErr, "/hl7:PRPA_IN201309UV02/hl7:controlActProcess/hl7:queryByParameter/hl7:parameterList/hl7:patientIdentifier/hl7:value/@root")
				}
			}
		}
		Set tSearchMRN=pSearchRequest.MRN
		#; if controlAA = SearchAA then we are searching by MPIID
		If tSearchAA=..AffinityDomain {
			Set pSearchRequest.AssigningAuthority=""
			Set pSearchRequest.MPIID=pSearchRequest.MRN,pSearchRequest.MRN=""
			Set tScopeFound(..AffinityDomain)=""
		} Else {
			Set:tSearchAA]"" tScopeFound(tSearchAA)=""
		}

		Set tSC = ..SendRequestSync(..MPIOperations,pSearchRequest,.tSearchResponse) 
		If $$$ISERR(tSC) {
			Set tErr = "Error executing MPI Search "_$system.Status.GetErrorText(tSC)
			If (pMsgFormat="v2")||(pMsgFormat="v3") {
				Do ..Errors.logError("204", tSeverityError, tErr)
			}
			Quit
		}

		#; we must know the requested ID or it is an error
		If tSearchResponse.Results.Count()=0 {
			Set tErr = "Requested record not found"
			If pMsgFormat="v2" {
				Do ..Errors.logError("204", tSeverityError, tErr, "QPD:3.1")
			} ElseIf pMsgFormat="v3" {
				Do ..Errors.logError("204", tSeverityError, tErr, "/hl7:PRPA_IN201309UV02/hl7:controlActProcess/hl7:queryByParameter/hl7:parameterList/hl7:patientIdentifier/hl7:value")
			}
			Quit
		}

		#; potentially the request scoped the response
		Set tXPATH="/hl7:PRPA_IN201309UV"_..IHEExtension_"/hl7:controlActProcess/hl7:queryByParameter/hl7:parameterList/hl7:dataSource/hl7:value"
		
		Set tNode="scopingOrganization_",tIdx=0
		For  {
			Set tIdx=tIdx+1
			Do pSearchRequest.AdditionalInfo.GetNext(.tNode) Quit:tNode=""
			If $P(tNode,"_",1)'="scopingOrganization" Quit
			Set tResult=$p(tNode,"_",2,999)
			Set tOID = ##class(HS.Data.OIDMap).GetOIDForCode(tResult,"")
			If tOID="" {
				Set tErr = "Unable to identify data source:"_tResult
				If pMsgFormat="v2" {
					Do ..Errors.logError(204, tSeverityError, tErr, "QPD:4")
				} ElseIf pMsgFormat="v3" {
					Do ..Errors.logError(204, tSeverityError, tErr, tXPATH_"["_tIdx_"]")
				}
			} Else {
				Set tScope(tResult)=""
			}
		}

		#; PIX query is a deterministic match, so we should only have one MPIID returned
		#; loop all ID's and insert additional identifiers
		Set tCount=tSearchResponse.Results.Count()
		For tIdx=1:1:tCount {
			Set tItem=tSearchResponse.Results.GetAt(tIdx)
			#; insert the MPIID if the MPI is the AffinityDomain 
			If tIdx = 1 && ..AffinityDomainIsMPIID {
				Set tMPIID = tItem.MPIID
				Set tResult = tItem.%ConstructClone(0)
				Set tResult.MRN=tMPIID
				Set tResult.AssigningAuthority = ..AffinityDomain
				Set tResult.Facility = ..AffinityDomain
				Do tSearchResponse.Results.Insert(tResult)
				Set tScopeFound(..AffinityDomain)=""
			}

			For tIdx2 = 1:1:tItem.Identifiers.Count() {
				Set tIdentifier = tItem.Identifiers.GetAt(tIdx2)
				Set tAA = tIdentifier.Root
				Set tMRN = tIdentifier.Extension
				If tAA="" || (tMRN="") continue
				Set tResult = tItem.%ConstructClone(0)
				Set tResult.MRN=tMRN
				Set tResult.AssigningAuthority = tAA
				Do tSearchResponse.Results.Insert(tResult)
				Set tScopeFound(tAA)=""
			}
		}

		$$$HSTRACE("SearchResponse","tSearchResponse",tSearchResponse)
		#; purge any id's not in scope or equal to search criteria
		For tIdx=1:1:tSearchResponse.Results.Count() {
			Set tItem=tSearchResponse.Results.GetAt(tIdx)
			Set tAA = tItem.AssigningAuthority
			$$$HSTRACE("checking item ","tIdx,tAA,tItem,$D(tScope),tSearchAA,tSearchMRN",tIdx,tAA,tItem,$D(tScope),tSearchAA,tSearchMRN)
			If tItem.MRN="" Continue
			If $D(tScope) && ('$D(tScope(tAA))) {
				Set tOtherIDs(tAA,tItem.MRN)=""
				Continue
			}
			#; exclude the searched item
			If tSearchAA = tAA && (tSearchMRN = tItem.MRN) Continue
			$$$HSTRACE("Adding","tSearchAA,tAA,tSearchMRN,tMRN,tIdx",tSearchAA,tAA,tSearchMRN,tItem.MRN,tIdx)
			Set tResult=##class(HS.Message.IHE.PatientSearchMatch).%New()
			Do tResult.CopyFrom(tItem,tResult)
			Set tResult.AssigningAuthority = tAA
			Set tFacility = tResult.Facility
			If tFacility'="" {
				Set tFacilityObject=##class(HS.Facility.Config).%OpenId(tFacility)
				If $isObject(tFacilityObject) {
					Set tFacilityName=$s(tFacilityObject.Name="":tFacilityObject.FacilityCode,1:tFacilityObject.Name)
					Set tFacilityTel =$S(tFacilityObject.Contact.Telephone="":"tel:Unknown",1:tFacilityObject.Contact.Telephone)
					Do tResult.AdditionalInfo.SetAt(tFacilityName,"FacilityName")
					Do tResult.AdditionalInfo.SetAt(tFacilityTel,"FacilityTelephone")
				}
				Else { Set tFacility=""}
			}
			/// Add the ID
			Set tMatch = ##class(HS.Message.IHE.Match).%New()
			Set tMatch.AssigningAuthority=tAA
			Set tMatch.MRN=tResult.MRN
			If tMatch.MRN="" Continue
			Do tResult.IDs.Insert(tMatch)
			Do addResult(pFilteredSearchResponse,tResult,.tScope,.tScopeFound)
		}
		#; move all matching ID's into first record and remove others
		Set tFirstID = pFilteredSearchResponse.Results.GetAt(1),tFacility=""
		If $isObject(tFirstID) {
			Set tHaveIDs(tFirstID.AssigningAuthority_" ",tFirstID.MRN_" ")=""
			For tIdx=pFilteredSearchResponse.Results.Count():-1:2 {
				Set tItem=pFilteredSearchResponse.Results.GetAt(tIdx)
				Set tAA = tItem.AssigningAuthority
				Set tMRN = tItem.MRN
				Set tFacility = tItem.Facility
				If tMRN]"",'$d(tHaveIDs(tAA_" ",tMRN_" ")) {
					Set tHaveIDs(tAA_" ",tMRN_" ")=""
					Set tMatch = ##class(HS.Message.IHE.Match).%New()
					Set tMatch.AssigningAuthority=tAA
					Set tMatch.MRN=tMRN
					Do tFirstID.IDs.Insert(tMatch)
					If tFacility]"",tFacility '= tFirstID.Facility Set tFirstID.Facility=""
				}
				Do pFilteredSearchResponse.Results.RemoveAt(tIdx)
			}
			/// put filtered ID's into OtherIDs so that users can use them where required (SWISS project)
			$$$HSTRACE("otherids "_$D(tOtherIDs))
			Set tAA="",tID=""
			For  {
				Set tAA=$O(tOtherIDs(tAA)) Quit:tAA=""
				For  {
					Set tID=$O(tOtherIDs(tAA,tID)) Quit:tID=""
					$$$HSTRACE("Adding otherid of "_tAA_"||"_tID)
					Do tFirstID.AdditionalInfo.SetAt("","OtherIDs_"_tAA_"||"_tID)
				}
			}
			Set tFacility = tFirstID.Facility 
		}
		#; can only present the facility (provider organization) if there is an ID associated
		If tFacility]"" && ('$d(tHaveIDs(tFacility_" "))) Set tFirstID.Facility=""
		$$$HSTRACE("Results","Count,tSearchResponse,FirstID",tSearchResponse.Results.Count(),tSearchResponse,tFirstID)
	} Catch eException {
		Set tSC = eException.AsStatus()
		Set tErr = "Internal Error:"_$system.Status.GetErrorText(tSC)
		If ($Get(pMsgFormat)="v2")||($Get(pMsgFormat)="v3") {
			Do ..Errors.logError("204", $Get(tSeverityError), tErr)
		}
	}

	Quit tSC
addResult(pFilteredResponse,pResult,pScoping,pScopeFound) //
	If pResult]"" {
		If pResult.MRN]"" {
			Do pFilteredResponse.Results.Insert(pResult)
			Set pScopeFound(pResult.AssigningAuthority)=""
		/* change for na 2010 Do pFilteredResponse.Results.Insert(pResult) */
		$$$HSTRACE("Adding Result","Result,MRN,MPIID,AA,Facility",pResult,pResult.MRN,pResult.MPIID,pResult.AA,pResult.Facility)
		}
	}
	Quit
}

Method MergePatientv2(pHL7Request As EnsLib.HL7.Message, Output pHL7Response As EnsLib.HL7.Message) As %Status
{
	Set tSC = $$$OK
	
	Try {
		Set tSC = ..HL7ToMergePatientRequest(pHL7Request, .tMergeRequest)
		If $$$ISERR(tSC) Quit
		If ..Errors.Errors.Count() Quit
		
		Set tSC = ..ValidateMergeAndSend(tMergeRequest, .tMergeResponse, 1)
		If $$$ISERR(tSC) Quit
		If ..Errors.Errors.Count() Quit
		
		Set tSC = ..MergePatientResponseToHL7(tMergeResponse, .pHL7Response, pHL7Request)
		If $$$ISERR(tSC) Quit
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

Method MergePatientv3(pRequest As HS.Message.XMLMessage, Output pResponse As HS.Message.XMLMessage) As %Status
{
	#dim tMergeRequest as HS.Message.MergePatientRequest
	#dim eException As %Exception.AbstractException
	
	Set tSC = $$$OK
	
	try {
		Set pResponse=pRequest.%New()
		Set pResponse.Name			= $$$PIXv3MergeResponse
		Set pResponse.DocType		= "MCCI_IN000002UV01"

		$$$HSTRACESTARTCALL
		Set tSC = ..Transformer.TransformIntoObject(pRequest.ContentStream,..TransformPIXToMergePatientRequest /*"IHE/PIX/Version1/PRPAIN201304UVToMergePatientRequest.xsl"*/,.tMergeRequest,.tXSLArguments,"HS.Message.MergePatientRequest","MergePatientRequest")
		$$$HSTRACEENDCALL
		If $$$ISERR(tSC) $$$LOGSTATUS(tSC)
		If $$$ISERR(tSC) Do ..Errors.logError("204","Error","unable to transform PIX request") Quit
		
		Set tSC = ..ValidateMergeAndSend(tMergeRequest, .tMergeResponse)

	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("204","Error","Unable run evaluation "_$system.Status.GetErrorText(tSC))
	}
	try {
		Set tOutput = ##class(%Stream.GlobalCharacter).%New()
		Do tOutput.Write("<root>")
		Do tOutput.Write("<originalRequest>")
		Do tOutput.CopyFrom(pRequest.ContentStream)
		Do tOutput.Write("</originalRequest>")
		Do ..Errors.XMLExportToString(.tErrorString)
		Do tOutput.Write(tErrorString)
		Do tOutput.Write("</root>")
		Do tOutput.Rewind()

		Kill tXSLArguments
		Set tXSLArguments=""
		Set tXSLArguments("messageID") = $System.Util.CreateGUID()
		Set tXSLArguments("creationTime") = ##class(HS.Util.XSLTHelper).timestamp()
		Set tXSLArguments("typeCode") = $S(..Errors.Errors.Count():"CE",1:"CA")
		$$$HSTRACESTARTCALL
		Set tSC = ..Transformer.Transform(tOutput,..TransformToMCCI /*"IHE/PIX/Version1/MCCI000002UV.xsl"*/,.tTarget,.tXSLArguments)
		$$$HSTRACEENDCALL
		If $$$ISOK(tSC) {
			Do tTarget.Rewind()
			Set pResponse.ContentStream=tTarget
		}
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("204","Error","Internal Error:"_$system.Status.GetErrorText(tSC))
	}
		
	Quit tSC
}

/// ValidateMergeAndSend is called by MergePatientv2 and MergePatientv3.
/// It validates the MergePatientRequest, sends it to the MPIOperations
/// and gets the response from the MPIOperations.
/// Input parameter pv2 indicates that this method is being called as part
/// of a PIXv2 MergePatient.  It is used for logging to ..Errors, because
/// of the differing requirements for error logging between v2 and v3.
Method ValidateMergeAndSend(pMergeRequest As HS.Message.MergePatientRequest, Output pMergeResponse As HS.Message.MergePatientResponse, pv2 As %Boolean = 0) As %Status
{
	#dim eException As %Exception.AbstractException
	
	Set tSC = $$$OK
	
	try {
		Set tSeverityError = $Select(pv2=1:"E",1:"Error")
		
		#dim tMergeRequest as HS.Message.MergePatientRequest
		If pMergeRequest.AssigningAuthority = ..AffinityDomain Do ..Errors.logError("204",tSeverityError,"PIX Manager does not support merging MPI ID's") Quit
		If pMergeRequest.PriorAssigningAuthority = ..AffinityDomain Do ..Errors.logError("204",tSeverityError,"PIX Manager does not support merging MPI ID's") Quit
		If pMergeRequest.AssigningAuthority="" || (pMergeRequest.PriorAssigningAuthority="") Do ..Errors.logError("204",tSeverityError,"Assigning authority or prior assigning authority not found") Quit
		If pMergeRequest.AssigningAuthority'=pMergeRequest.PriorAssigningAuthority Do ..Errors.logError("204",tSeverityError,"New assigning authority does not match prior assigning authority") Quit
		#; if the facility is null we need to find all records for this MRN / AA and issue merge requests
		///SAML note: merge request does not extend RequestInfo at this time
		If pMergeRequest.Facility="" {
			Set tSearchRequest = ##class(HS.Message.PatientSearchRequest).%New()
			Set tSearchRequest.MRN=pMergeRequest.PriorMRN
			Set tSearchRequest.AssigningAuthority=pMergeRequest.PriorAssigningAuthority
			Set tSearchRequest.SearchMode=$S(..ApplyConsent:"PIXPDQ_c",1:"PIXPDQ")
			Set tSC = ..SendRequestSync(..MPIOperations,tSearchRequest,.tSearchResponse) 
			For tIdx = 1:1:tSearchResponse.Results.Count() {
				Set tResult = tSearchResponse.Results.GetAt(tIdx)
				If tResult.MRN'=pMergeRequest.PriorMRN || (tResult.AssigningAuthority '= pMergeRequest.AssigningAuthority) Continue
				Set pMergeRequest.Facility=tResult.Facility
				Set tSC=..SendRequestSync(..MPIOperations,pMergeRequest,.pMergeResponse) 
				If $$$ISERR(tSC) Do ..Errors.logError("204",tSeverityError,"Error sending MPI request "_$system.Status.GetErrorText(tSC))
			}
		} Else {
			Set tSC=..SendRequestSync(..MPIOperations,pMergeRequest,.pMergeResponse) 
			If $$$ISERR(tSC) Do ..Errors.logError("204",tSeverityError,"Error sending MPI request "_$system.Status.GetErrorText(tSC)) 
		}
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("204",$Get(tSeverityError),"Unable run evaluation "_$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

/* for each identifier find the consumers interested and then build a message

*/
Method UpdateNotification(pRequest As HS.Message.IDUpdateNotificationRequest) As %Status
{
	Try {
		Set tSC =$$$OK
		$$$HSTRACE("notification value","pRequest",pRequest)
		Set tDemographics = pRequest.PatientDemographics,tIdents=1
		Set:'$IsObject(tDemographics) tDemographics = ##class(HS.Message.PatientSearchMatch).%New()
		Set tIdentifier = ##class(HS.Types.Identifier).%New()
		Set tIdentifier.Extension=pRequest.MPIID
		Set tIdentifier.Root=..AffinityDomain
		Do tDemographics.Identifiers.Clear()
		Do pRequest.Identifiers.Insert(tIdentifier)
		set tConsumersList=##class(%Library.ListOfDataTypes).%New()
		; some consumers take all updates, but only if at least one of the identifiers is from a particular Assigning Authority
		; get the list of those consumers to use later
		do ##class(HS.IHE.PIX.Manager.DomainsOfInterest).RegisteredOnlyConsumers(pRequest.Identifiers,.tConsumersList)
		do ##class(HS.IHE.PIX.Manager.DomainsOfInterest).RegisteredOnlyConsumers(pRequest.PriorIdentifiers,.tConsumersList)

		For tCollection = pRequest.Identifiers,pRequest.PriorIdentifiers {
			For tIdx = 1:1:tCollection.Count() {
				Set tIdentifier = tCollection.GetAt(tIdx)
				$$$HSTRACE("Checking Consumers to notify:"_tIdentifier.Root)
				Continue:tIdentifier.Root=""
				Set tSC = ##class(HS.IHE.PIX.Manager.DomainsOfInterest).ConsumersToNotify(tIdentifier.Root,.tConsumerIDS,.tConsumersList)
				#; only insert current identifiers, need to check the priors to get all domains of interest
				If tIdents {
					$$$HSTRACE("Inserting identifier:"_tIdx,"tIdentifier",tIdentifier)
					Do tDemographics.Identifiers.Insert(tIdentifier)
				}
			}
			#; for identifiers (not prior) insert the identifiers into the patient demographics
			Set tIdents=0
		}
		Set tConsumer=""
		For  {
			Set tConsumer = $o(tConsumerIDS(tConsumer)) Quit:tConsumer=""
			Set tDemoCopy = tDemographics.%ConstructClone(1)
			For tIdx=tDemoCopy.Identifiers.Count():-1:1 {
				Set tIdentifier=tDemoCopy.Identifiers.GetAt(tIdx)
				If '$D(tConsumerIDS(tConsumer,tIdentifier.Root)) Do tDemoCopy.Identifiers.RemoveAt(tIdx)
			}
			If tDemoCopy.Identifiers.Count()=0 Continue
			Set tEndPointv3 = ##class(HS.Registry.Service.Abstract).EndPointForID(tConsumer,"Device","PIXv3.Consumer","SOAP")
			Set tEndPointv2 = ##class(HS.Registry.Service.Abstract).EndPointForID(tConsumer,"Device","PIXv2.Consumer","TCP")
			If '$IsObject(tEndPointv2) && '$IsObject(tEndPointv3) $$$LOGERROR("Cannot Locate EndPoint for Device OID "_tConsumer) continue
			If $IsObject(tEndPointv3) {
				If tDemoCopy.Facility'="" {
					Set tFacObj = ##class(HS.Facility.Config).%OpenId(tDemoCopy.Facility)
					If $IsObject(tFacObj) {
						If tFacObj.Name'="" Do tDemoCopy.AdditionalInfo.SetAt(tFacObj.Name,"FacilityName")
						If tFacObj.Contact.Telephone'="" Do tDemoCopy.AdditionalInfo.SetAt(tFacObj.Contact.Telephone,"FacilityTelephone")
					}
					Kill tFacObj
				}
				Set tSC = tDemoCopy.XMLExportToStream(.tOutput) Quit:$$$ISERR(tSC)
				Set tDescription = $tr(##class(HS.Data.OIDMap).OIDDescription($$$AffinityDomainOID),$c(0))
				Set:tDescription="" tDescription=..AffinityDomain
				Set tXSLArguments("messageID") = $System.Util.CreateGUID()
				Set tXSLArguments("creationTime") = ##class(HS.Util.XSLTHelper).timestamp()
				Set tXSLArguments("receiverDeviceOID") = ##class(HS.Data.OIDMap).OIDForType(tConsumer,"Device")
				Set tXSLArguments("senderDeviceOID") = ##class(HS.Data.OIDMap).OIDForType(..DeviceID,"Device")
				Set tXSLArguments("custodian") = ..AffinityDomain
				Set tXSLArguments("custodianName") = $ZCVT(tDescription,"O","XML")
				Set tXSLArguments("PriorMPIID")=$S($D(tConsumerIDS(tConsumer,..AffinityDomain)):pRequest.PriorMPIID,1:"")
				$$$HSTRACESTARTCALL
				Set tSC = ..Transformer.Transform(tOutput,..TransformMatchToUpdateNotification /*"IHE/PIX/Version1/PatientSearchMatchToPRPAIN201302UV.xsl"*/,.tTarget,.tXSLArguments) 
				$$$HSTRACEENDCALL
				If $$$ISOK(tSC) {
					Set tRequest = ##class(HS.Message.XMLMessage).%New()
					Do tRequest.ContentStream.CopyFrom(tTarget)
					Do tRequest.AdditionalInfo.SetAt($$$PIXv3ReviseAction(..IHEVersion),"SOAPAction")
					Do tRequest.AdditionalInfo.SetAt(tEndPointv3.Name,"ServiceName")
					Set tRequest.Name = $$$PIXv3ReviseRequest
					$$$HSTRACE("PIXv3_PatientReviseRequest to PIXv3Operations","tRequest",tRequest)
					Set tSC = ..SendRequestAsync(..PIXv3Operations, tRequest, .tResponse)
					Do $$$ATNAEvent("PIXv3Manager", tRequest, , tSC)
					/// what to do with an error
					If $$$ISERR(tSC) $$$LOGSTATUS(tSC)
				} Else {
					$$$HSTRACE("error","tSC",tSC)
				}
			}
			If $IsObject(tEndPointv2) {
				#; Transform IDUpdateNotificationRequest to HL7 ADT_A31
				Set tSC = ..IDUpdateNotificationToHL7(tEndPointv2, tDemoCopy, .tHL7Request)
				$$$ThrowOnError(tSC)
				Set tHL7Request.Envelope = "|ServiceName="_tEndPointv2.Name_"|"
				$$$HSTRACE("HL7 Request to PIXv2Operations","tHL7Request",tHL7Request.OutputToString())
				Set tSC = ..SendRequestSync(..PIXv2Operations, tHL7Request, .tHL7Response)
				Do $$$ATNAEvent("PIXv2Manager", tHL7Request, tHL7Response, tSC)
				#; what to do with an error
				If $$$ISERR(tSC) $$$LOGSTATUS(tSC)
			}
		}
	} catch ex {
		Set tSC = ex.AsStatus()
		$$$LOGSTATUS(tSC)
		Do ..Errors.logError("204","Error","Internal Error:"_$system.Status.GetErrorText(tSC))
	}
	Quit tSC
}

Method HL7ToAddOrUpdateRequest(pSource As EnsLib.HL7.Message, ByRef pTarget As HS.Message.AddUpdateHubRequest) As %Status
{
	Set tSC = $$$OK
	
	Try {
		#; IHE requires 2.3.1, so force the document type assignment		
		Set pSource.DocType = "2.3.1:ADT_A01"
		
		#; Instantiate target message
		Set pTarget = ##class(HS.Message.AddUpdateHubRequest).%New()
				
		Set pTarget.AddOrUpdate = "F"
		Set pTarget.DoMPIUpdate = 1
		
		Set pTarget.Facility = pSource.GetValueAt("MSH:4.1")
		
		#; Person's Name - going to assume we never want to blank out the person's first or last name.
		Set pTarget.Prefix = ..AddUpdateGetValueAt(pSource, "PID:5.5")
		Set pTarget.FirstName = pSource.GetValueAt("PID:5.2")
		Set pTarget.MiddleName = ..AddUpdateGetValueAt(pSource, "PID:5.3")
		Set pTarget.LastName = pSource.GetValueAt("PID:5.1")
		Set pTarget.Suffix = ..AddUpdateGetValueAt(pSource, "PID:5.4")
		
		#; Person's Address
		Set tAddressCount = pSource.GetValueAt("PID:11(*)")
		For tIdx=1:1:tAddressCount{
			If pSource.GetValueAt("PID:11("_tIdx_")")'="""""" {
				Set tAddress = ##class(HS.Types.Address).%New()
				Set tAddress.StreetLine = ..AddUpdateGetValueAt(pSource, "PID:11("_tIdx_").1.1")
				Set tAddress.City = ..AddUpdateGetValueAt(pSource, "PID:11("_tIdx_").3")
				Set tAddress.State = ..AddUpdateGetValueAt(pSource, "PID:11("_tIdx_").4")
				Set tAddress.PostalCode = ..AddUpdateGetValueAt(pSource, "PID:11("_tIdx_").5")
				Set tAddress.Country = ..AddUpdateGetValueAt(pSource, "PID:11("_tIdx_").6")
				Set tUse = ..ConvertAddressUse(pSource.GetValueAt("PID:11("_tIdx_").7"))
				Set tAddress.Use = tUse
				If tAddress.StreetLine'=""!(tAddress.City'="")!(tAddress.State'="")!(tAddress.PostalCode'="")!(tAddress.Country'="") {
					Do pTarget.Addresses.Insert(tAddress)
				}
			}
		}
		
		#; Person's Telecoms
		#; tPIDPosition = 13 is Home Phone
		#; tPIDPosition = 14 is Business Phone
		For tPIDPosition = 13,14 {
			For tIndex = 1:1:pSource.GetValueAt("PID:"_tPIDPosition_"(*)") {
				Set tUnformattedNumber = pSource.GetValueAt("PID:"_tPIDPosition_"("_tIndex_").1")
				Set tUseCode = pSource.GetValueAt("PID:"_tPIDPosition_"("_tIndex_").2")
				Set tEquipmentType = pSource.GetValueAt("PID:"_tPIDPosition_"("_tIndex_").3")
				Set tCountryCode = pSource.GetValueAt("PID:"_tPIDPosition_"("_tIndex_").5")
				Set tAreaCode = pSource.GetValueAt("PID:"_tPIDPosition_"("_tIndex_").6")
				Set tLocalNumber = pSource.GetValueAt("PID:"_tPIDPosition_"("_tIndex_").7")
				If tUnformattedNumber'="" {
					Set tTelecomObj = ##class(HS.Types.Telecom).%New()
					Set tTelecomObj.PhoneNumberFull = tUnformattedNumber
					If tPIDPosition=13 Set tTelecomObj.Use = "HP"
					If tPIDPosition=14 Set tTelecomObj.Use = "WP"
					Set tSC = pTarget.Telecoms.Insert(tTelecomObj)
					Kill tTelecomObj
				} ElseIf tLocalNumber'="" {
					Set tTelecomObj = ##class(HS.Types.Telecom).%New()
					Set tTelecomObj.PhoneNumber = tLocalNumber
					Set tTelecomObj.PhoneAreaCode = tAreaCode
					Set tTelecomObj.PhoneCountryCode = tCountryCode
					If tUseCode="H" Set tTelecomObj.Use = "H"
					If tUseCode="PRN"!(tUseCode="HP")!(tUseCode="ORN") Set tTelecomObj.Use = "HP"
					If tUseCode="W"!(tUseCode="WP")!(tUseCode="WPN") Set tTelecomObj.Use = "WP"
					If tUseCode="VHN" Set tTelecomObj.Use = "HV"
					If tUseCode="ASN" Set tTelecomObj.Use = "AS"
					If tUseCode="EMR" Set tTelecomObj.Use = "EC"
					If tTelecomObj.Use="" If tPIDPosition=13 Set tTelecomObj.Use = "HP"
					If tTelecomObj.Use="" If tPIDPosition=14 Set tTelecomObj.Use = "WP"
					If tEquipmentType="PH"!(tEquipmentType="L") Set tTelecomObj.Type = "L"
					If tEquipmentType="FX"!(tEquipmentType="F") Set tTelecomObj.Type = "F"
					If tEquipmentType="CP"!(tEquipmentType="M") Set tTelecomObj.Type = "M"
					If tEquipmentType="BP"!(tEquipmentType="P") Set tTelecomObj.Type = "P"
					Set tSC = pTarget.Telecoms.Insert(tTelecomObj)
					Kill tTelecomObj
				}
			}
		}
		
		#; Person's Identifiers
		
		Set tAffinityDomainOID = ##class(HS.Data.OIDMap).GetOIDForCode(..AffinityDomain)
		Set tGotMRN = 0
		
		#; Iterate over PID:3 and PID:4 and PID:2 collections
		For tPIDPosition = 3,4,2 {
			For tCount = 1:1:pSource.GetValueAt("PID:"_tPIDPosition_"(*)") {
				#; Parse identifier details
				#; If this field is blank (no identifier, no AA) then ignore it.
				If pSource.GetValueAt("PID:"_tPIDPosition_"("_tCount_").1")="",pSource.GetValueAt("PID:"_tPIDPosition_"("_tCount_").4")="" continue
				
				Set tIdentifier = pSource.GetValueAt("PID:"_tPIDPosition_"("_tCount_").1")
				If tIdentifier="" Do ..Errors.logError("101","E","Missing Identifier","PID:"_tPIDPosition_"("_tCount_").1") Quit
				Set tIdentifierType = pSource.GetValueAt("PID:"_tPIDPosition_"("_tCount_").5")
				
				#; ITI TF Vol2a Section 3.8.4.1.2.3
				#; Assigning Authority may have code and oid and universal type,
				#; or just code, or just oid and universal type.  If code and
				#; oid are populated then they must reference the same thing.
				Do ..ValidateOIDAndCode(pSource, "PID:"_tPIDPosition_"("_tCount_")", ..MatchCodeWithOID, "Assigning Authority", .tAssigningAuthorityCode, .tAssigningAuthorityOID)
				If ..Errors.Errors.Count() Quit
				
				If tIdentifier ] "" {
					#; Get MRN if we need to.
					#; The only indicator that tIdentifier is an MPIID is
					#; that the AA OID matches the affinity domain OID.
					If tAssigningAuthorityOID'=tAffinityDomainOID {
						Set tSC = ##class(HS.IHE.Util).AAIdentifierTypeForCode(tAssigningAuthorityCode, .tAAIdentifierType,..ExcludeIdentifierTypes)
						If $$$ISERR(tSC)!(tAAIdentifierType="") {
							$$$LOGINFO("Unknown Assigning Authority Type for "_tAssigningAuthorityCode_" - removed Identifier")
						} ElseIf tGotMRN=0,tAAIdentifierType="MR" {
							Set pTarget.AssigningAuthority = tAssigningAuthorityCode
							Set pTarget.MRN = tIdentifier
							Set tGotMRN = 1
						} ElseIf tAAIdentifierType'="MR" {
							#; Get other identifiers
							Set tNewIdentifer = ##class(HS.Types.Identifier).%New()
							Set tNewIdentifer.Root = tAssigningAuthorityCode
							Set tNewIdentifer.Extension = tIdentifier
							Set tNewIdentifer.AssigningAuthorityName = tAssigningAuthorityCode
							Set tNewIdentifer.Use = tAAIdentifierType
							Do pTarget.Identifiers.Insert(tNewIdentifer)
						}
					}
					Else {
						#; Get other identifiers
						Set tNewIdentifer = ##class(HS.Types.Identifier).%New()
						Set tNewIdentifer.Root = tAssigningAuthorityCode
						Set tNewIdentifer.Extension = tIdentifier
						Set tNewIdentifer.AssigningAuthorityName = tAssigningAuthorityCode
						Set tNewIdentifer.Use = "PT"
						Do pTarget.Identifiers.Insert(tNewIdentifer)
					}
				}
			}
		}
		If ..Errors.Errors.Count()>0 Quit
		If tGotMRN=0 Do ..Errors.logError("204","E","No MRN found") Quit
		
		#; Other identifiers
		Set tPID19 = ..AddUpdateGetValueAt(pSource, "PID:19")
		Set pTarget.SSN = $Case((tPID19?3N.1"-".2N."-".4N) || (tPID19?9N), 1:tPID19, :"")
		Set pTarget.DriversLicenseNumber = ..AddUpdateGetValueAt(pSource, "PID:20.1")
		
		#; Other Values
		Set pTarget.Sex = pSource.GetValueAt("PID:8")
		Set tHL7DOB = pSource.GetValueAt("PID:7.1")
		If tHL7DOB'="",$Length(tHL7DOB)<8 Do ..Errors.logError("204","E","Invalid Date of Birth") Quit
		If tHL7DOB'="" Set pTarget.DOB = $ZDateH($Extract(tHL7DOB, 1, 4) _ "-" _ $Extract(tHL7DOB, 5, 6) _ "-" _ $Extract(tHL7DOB, 7, 8), 3)
		Set pTarget.MaritalStatus = ..AddUpdateGetValueAt(pSource, "PID:16.1")
		Set pTarget.ReligiousAffiliation = ..AddUpdateGetValueAt(pSource, "PID:17.1")
		Set pTarget.Language = ..AddUpdateGetValueAt(pSource, "PID:15.1")
		Set pTarget.Race = ..AddUpdateGetValueAt(pSource, "PID:10.1")
		Set pTarget.EthnicGroup = ..AddUpdateGetValueAt(pSource, "PID:22.1")
		Set pTarget.MothersMaidenSurname = ..AddUpdateGetValueAt(pSource, "PID:6.1.1")
		Set pTarget.VIP = $Select(..AddUpdateGetValueAt(pSource, "PV1:16")=1:1,1:"")
		
		#; Copy Assigning Authority Code to Facility if necessary
		If pTarget.Facility="" Set pTarget.Facility = pTarget.AssigningAuthority
		If pTarget.Facility'="",##class(HS.Facility.Config).%ExistsId(pTarget.Facility) {
			Set pTarget.GatewayName = ##class(HS.Facility.Config).%OpenId(pTarget.Facility).Gateway.Name
		}
		
		#; Resolve and capture Sender Device OID
		Set tSendingDeviceOID = $Case(pSource.GetValueAt("MSH:3.1") '= "", 1:##class(HS.Data.OIDMap).OIDForType(pSource.GetValueAt("MSH:3.1"), "Device"), :"")
		If (tSendingDeviceOID '= "") { Do pTarget.AdditionalInfo.SetAt(tSendingDeviceOID, "SenderOID") }
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

Method AddOrUpdateResponseToHL7(pSource As HS.Message.AddUpdateHubResponse, ByRef pTarget As EnsLib.HL7.Message, pOriginalRequest As EnsLib.HL7.Message) As %Status
{
	Set tSC = $$$OK
	
	Try {
		#; Instantiate target message
		Set pTarget = ##class(EnsLib.HL7.Message).%New()
		
		#; IHE requires 2.5, so force the document type assignment		
		Set pTarget.DocType = "2.5:ACK"
		
		#; Force original request's document type to be ADT_A01
		Set pOriginalRequest.DocType = "2.5:ADT_A01"
		
		#; Message Header (MSH)
		Do pTarget.SetValueAt("ACK", "MSH:9.1")
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:9.2") , "MSH:9.2")
		Do pTarget.SetValueAt("ACK", "MSH:9.3")
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:5.1"), "MSH:3.1") // Sending Application
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:6.1"), "MSH:4.1") // Sending Facility
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:3.1"), "MSH:5.1") // Receiving Application
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:4.1"), "MSH:6.1") // Receiving Facility
		Do pTarget.SetValueAt($Translate($ZDateTime($Horolog, 3), "-: ", ""), "MSH:7.1") // Message Date/Time
		Do pTarget.SetValueAt(##class(HS.IHE.Util).GetIdForHL7(),"MSH:10") // Message Control ID
		Do pTarget.SetValueAt("P","MSH:11") // Processing ID (P = Production)
		Do pTarget.SetValueAt("2.3.1", "MSH:12")
		
		#; Message Acknowledgment (MSA)
		If $$$ISOK(pSource.ErrStatus) {
			Do pTarget.SetValueAt("AA", "MSA:1")
			Do pTarget.SetValueAt(pSource.MPIID, "MSA:3")
		}
		Else {
			Do pTarget.SetValueAt("AE", "MSA:1")
			Do pTarget.SetValueAt($System.Status.GetOneErrorText(pSource.ErrStatus), "ERR:1")
		}
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:10"), "MSA:2")
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

Method HL7ToMergePatientRequest(pSource As EnsLib.HL7.Message, ByRef pTarget As HS.Message.MergePatientRequest) As %Status
{
	Set tSC = $$$OK
	
	Try {
		#; IHE requires 2.3.1, so force the document type assignment		
		Set pSource.DocType = "2.3.1:ADT_A39"
		
		#; Instantiate target message
		Set pTarget = ##class(HS.Message.MergePatientRequest).%New()
		
		Set pTarget.Facility = pSource.GetValueAt("MSH:4.1")
		
		Set tAffinityDomainOID = ##class(HS.Data.OIDMap).GetOIDForCode(..AffinityDomain,"")
		
		#; Iterate over PID:3 and PID:4 and PID:2 collections
		Set tGotMRN = 0
		For tPIDPosition = 3,4,2 {
			For tCount = 1:1:pSource.GetValueAt("PIDgrp(1).PID:"_tPIDPosition_"(*)") {
				#; Parse identifier details
				#; If this field is blank (no identifier, no AA) then ignore it.
				If pSource.GetValueAt("PIDgrp(1).PID:"_tPIDPosition_"("_tCount_").1")="",pSource.GetValueAt("PIDgrp(1).PID:"_tPIDPosition_"("_tCount_").4")="" continue
								
				Set tIdentifier = pSource.GetValueAt("PIDgrp(1).PID:"_tPIDPosition_"("_tCount_").1")
				If tIdentifier="" Do ..Errors.logError("101","E","Missing Identifier","PIDgrp(1).PID:"_tPIDPosition_"("_tCount_").1") Quit
				Set tIdentifierType = pSource.GetValueAt("PIDgrp(1).PID:"_tPIDPosition_"("_tCount_").5")
				
				#; ITI TF Vol2a Section 3.8.4.1.2.3
				#; Assigning Authority may have code and oid and universal type,
				#; or just code, or just oid and universal type.  If code and
				#; oid are populated then they must reference the same thing.
				Do ..ValidateOIDAndCode(pSource, "PIDgrp(1).PID:"_tPIDPosition_"("_tCount_")", ..MatchCodeWithOID, "Assigning Authority", .tAssigningAuthorityCode, .tAssigningAuthorityOID)
				If ..Errors.Errors.Count() Quit
				
				If tIdentifier ] "" {
					#; Get MRN if we need to.
					#; The only indicator that tIdentifier is an MPIID is
					#; that the AA OID matches the affinity domain OID.
					If tAssigningAuthorityOID'=tAffinityDomainOID {
						Set tSC = ##class(HS.IHE.Util).AAIdentifierTypeForCode(tAssigningAuthorityCode, .tAAIdentifierType,..ExcludeIdentifierTypes)
						If $$$ISERR(tSC)!(tAAIdentifierType="") {
							$$$LOGINFO("Unknown Assigning Authority Type for "_tAssigningAuthorityCode_" - removed Identifier")
						} ElseIf tGotMRN=0,tAAIdentifierType="MR" {
							Set pTarget.AssigningAuthority = tAssigningAuthorityCode
							Set pTarget.MRN = tIdentifier
							Set tGotMRN = 1
						}
					}
				}
			}
		}
		If tGotMRN=0 Do ..Errors.logError("204","E","No MRN found") Quit
		
		#; Person's prior identifiers (for merge events)
		#; Iterate over MRG:4 and MRG:1 collections
		Set tGotMRN = 0
		For tPIDPosition = 4,1 {
			For tCount = 1:1:pSource.GetValueAt("PIDgrp(1).MRG:"_tPIDPosition_"(*)") {
				#; Parse identifier details
				#; If this field is blank (no identifier, no AA) then ignore it.
				If pSource.GetValueAt("PIDgrp(1).MRG:"_tPIDPosition_"("_tCount_").1")="",pSource.GetValueAt("PIDgrp(1).MRG:"_tPIDPosition_"("_tCount_").4")="" continue
								
				Set tIdentifier = pSource.GetValueAt("PIDgrp(1).MRG:"_tPIDPosition_"("_tCount_").1")
				If tIdentifier="" Do ..Errors.logError("101","E","Missing Identifier","PIDgrp(1).MRG:"_tPIDPosition_"("_tCount_").1") Quit
				Set tAAIdentifierType = pSource.GetValueAt("PIDgrp(1).MRG:"_tPIDPosition_"("_tCount_").5")
				
				#; ITI TF Vol2a Section 3.8.4.1.2.3
				#; Assigning Authority may have code and oid and universal type,
				#; or just code, or just oid and universal type.  If code and
				#; oid are populated then they must reference the same thing.
				Do ..ValidateOIDAndCode(pSource, "PIDgrp(1).MRG:"_tPIDPosition_"("_tCount_")", ..MatchCodeWithOID, "Assigning Authority", .tAssigningAuthorityCode, .tAssigningAuthorityOID)
				If ..Errors.Errors.Count() Quit
				
				If tIdentifier ] "" {
					#; Get MRN if we need to.
					#; The only indicator that tIdentifier is an MPIID is
					#; that the AA OID matches the affinity domain OID.
					If tAssigningAuthorityOID'=tAffinityDomainOID {
						If tAAIdentifierType="" {
							Set tSC = ##class(HS.IHE.Util).AAIdentifierTypeForCode(tAssigningAuthorityCode, .tAAIdentifierType,..ExcludeIdentifierTypes)
						}
						If $$$ISERR(tSC)!(tAAIdentifierType="") {
							$$$LOGINFO("Unknown Assigning Authority Type for "_tAssigningAuthorityCode_" - removed Identifier")
						} ElseIf tGotMRN=0,tAAIdentifierType="MR" {
							Set pTarget.PriorAssigningAuthority = tAssigningAuthorityCode
							Set pTarget.PriorMRN = tIdentifier
							Set tGotMRN = 1
						}
					}
				}
			}
		}
		If tGotMRN=0 Do ..Errors.logError("204","E","No Prior MRN found") Quit
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

Method MergePatientResponseToHL7(pSource As HS.Message.MergePatientResponse, ByRef pTarget As EnsLib.HL7.Message, pOriginalRequest As EnsLib.HL7.Message) As %Status
{
	Set tSC = $$$OK
	
	Try {
		#; Instantiate target message
		Set pTarget = ##class(EnsLib.HL7.Message).%New()
		
		#; IHE requires 2.5, so force the document type assignment		
		Set pTarget.DocType = "2.5:ACK"
		
		#; Force original request's document type to be ADT_A01
		Set pOriginalRequest.DocType = "2.5:ADT_A01"
		
		#; Message Header (MSH)
		Do pTarget.SetValueAt("ACK", "MSH:9.1")
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:9.2") , "MSH:9.2")
		Do pTarget.SetValueAt("ACK", "MSH:9.3")
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:5.1"), "MSH:3.1") // Sending Application
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:6.1"), "MSH:4.1") // Sending Facility
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:3.1"), "MSH:5.1") // Receiving Application
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:4.1"), "MSH:6.1") // Receiving Facility
		Do pTarget.SetValueAt($Translate($ZDateTime($Horolog, 3), "-: ", ""), "MSH:7.1") // Message Date/Time
		Do pTarget.SetValueAt(##class(HS.IHE.Util).GetIdForHL7(),"MSH:10") // Message Control ID
		Do pTarget.SetValueAt("P","MSH:11") // Processing ID (P = Production)
		Do pTarget.SetValueAt("2.3.1", "MSH:12")
		
		#; Message Acknowledgment (MSA)
		If $$$ISOK(pSource.Accepted) {
			Do pTarget.SetValueAt("AA", "MSA:1")
			Do pTarget.SetValueAt(pSource.TargetMPIID, "MSA:3")
		}
		Else {
			Do pTarget.SetValueAt("AE", "MSA:1")
			Do pTarget.SetValueAt(pSource.Text, "ERR:1")
		}
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:10"), "MSA:2")
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

Method HL7ToPatientSearchRequest(pSource As EnsLib.HL7.Message, ByRef pTarget As HS.Message.PatientSearchRequest) As %Status
{
	Set tSC = $$$OK
	
	Try {
		#; IHE requires 2.5, so force the document type assignment		
		Set pSource.DocType = "2.5:QBP_Q21"
		
		#; Instantiate target message
		Set pTarget = ##class(HS.Message.PatientSearchRequest).%New()
		
		#; Establish request as a PIX/PDQ request
		Set pTarget.SearchMode = $S(..ApplyConsent:"PIXPDQ_c",1:"PIXPDQ")

		#; Person's local identifier
		Set tIdentifier = pSource.GetValueAt("QPD:3.1")
		If tIdentifier="" Do ..Errors.logError("101","E","Missing Identifier","QPD:3.1") Quit
		Set tIdentifierType = pSource.GetValueAt("QPD:3.5")
		
		Set tAffinityDomainOID = ##class(HS.Data.OIDMap).GetOIDForCode(..AffinityDomain)
		
		#; ITI TF Vol2a Section 3.9.4.1.2.2
		#; Assigning Authority may have code and oid and universal type,
		#; or just code, or just oid and universal type.  If code and
		#; oid are populated then they must reference the same thing.
		#; Same rules apply to QPD:4.
		Do ..ValidateOIDAndCode(pSource, "QPD:3", ..MatchCodeWithOID, "Assigning Authority", .tAssigningAuthorityCode, .tAssigningAuthorityOID)
		If ..Errors.Errors.Count() Quit
		
		If tIdentifier ] "" {
			#; Get MRN if we need to.
			#; The only indicator that tIdentifier is an MPIID is
			#; that the AA OID matches the affinity domain OID.
			If tAssigningAuthorityOID'=tAffinityDomainOID {
				Set tSC = ##class(HS.IHE.Util).AAIdentifierTypeForCode(tAssigningAuthorityCode, .tAAIdentifierType,..ExcludeIdentifierTypes)
				If $$$ISERR(tSC)!(tAAIdentifierType="") {
					$$$LOGINFO("Unknown Assigning Authority Type for "_tAssigningAuthorityCode_" - removed Identifier")
				} ElseIf tAAIdentifierType="MR" {
					Set pTarget.AssigningAuthority = tAssigningAuthorityCode
					Set pTarget.MRN = tIdentifier
				} Else {
					#; Get other identifiers
					Set tNewIdentifer = ##class(HS.Types.Identifier).%New()
					Set tNewIdentifer.Root = tAssigningAuthorityCode
					Set tNewIdentifer.Extension = tIdentifier
					Set tNewIdentifer.AssigningAuthorityName = tAssigningAuthorityCode
					Set tNewIdentifer.Use = tAAIdentifierType
					Do pTarget.Identifiers.Insert(tNewIdentifer)
				}
			}
			Else {
				#; Perform search based on other identifier
				Set tNewIdentifer = ##class(HS.Types.Identifier).%New()
				Set tNewIdentifer.Root = tAssigningAuthorityCode
				Set tNewIdentifer.Extension = tIdentifier
				Set tNewIdentifer.AssigningAuthorityName = tAssigningAuthorityCode
				Set tNewIdentifer.Use = "PT"
				Do pTarget.Identifiers.Insert(tNewIdentifer)
				Set pTarget.MPIID = tIdentifier
			}
		}
		
		#; Target domain(s) to filter the response by.
		Set tDomainFound = 0
		Set tQPDDomainsField = 4
		For i = 1:1:pSource.GetValueAt("QPD:"_tQPDDomainsField_"(*)") {
			Set tFacilityCode = pSource.GetValueAt("QPD:"_tQPDDomainsField_"("_i_").4.1")
			Set tFacilityOID = pSource.GetValueAt("QPD:"_tQPDDomainsField_"("_i_").4.2")
			If tFacilityCode="",tFacilityOID="" continue
			$$$HSTRACE("Evaluating scoping organization","tFacilityOID,tFacilityCode",tFacilityOID,tFacilityCode)
			Do ..ValidateOIDAndCode(pSource, "QPD:"_tQPDDomainsField_"("_i_")", ..MatchCodeWithOID, "Facility", .tFacilityCode, .tFacilityOID)
			If ..Errors.Errors.Count() Quit
			
			Do pTarget.AdditionalInfo.SetAt("","scopingOrganization_"_tFacilityCode)
			Set tDomainFound = 1
		}
		If ..Errors.Errors.Count() Quit
		If tDomainFound=1 Do pTarget.AdditionalInfo.SetAt("","ScopingOrganizations")
		
		#; Resolve and capture Sender Device OID
		Set tSendingDeviceOID = $Case(pSource.GetValueAt("MSH:3.1") '= "", 1:##class(HS.Data.OIDMap).OIDForType(pSource.GetValueAt("MSH:3.1"), "Device"), :"")
		If (tSendingDeviceOID '= "") { Do pTarget.AdditionalInfo.SetAt(tSendingDeviceOID, "SenderOID") }
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

Method PatientSearchResponseToHL7(pSource As HS.Message.PatientSearchResponse, ByRef pTarget As EnsLib.HL7.Message, pOriginalRequest As EnsLib.HL7.Message) As %Status
{
	Set tSC = $$$OK
	
	Try {
		#; Instantiate target message
		Set pTarget = ##class(EnsLib.HL7.Message).%New()
		
		#; IHE requires 2.5, so force the document type assignment		
		Set pTarget.DocType = "2.5:RSP_K23"
		
		#; Message Header (MSH)
		Do pTarget.SetValueAt("RSP", "MSH:9.1")
		Do pTarget.SetValueAt("K23", "MSH:9.2")
		Do pTarget.SetValueAt("RSP_K23", "MSH:9.3")
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:5.1"), "MSH:3.1") // Sending Application
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:6.1"), "MSH:4.1") // Sending Facility
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:3.1"), "MSH:5.1") // Receiving Application
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:4.1"), "MSH:6.1") // Receiving Facility
		Do pTarget.SetValueAt($Translate($ZDateTime($Horolog, 3), "-: ", ""), "MSH:7.1") // Message Date/Time
		Do pTarget.SetValueAt(##class(HS.IHE.Util).GetIdForHL7(),"MSH:10") // Message Control ID
		Do pTarget.SetValueAt("P","MSH:11") // Processing ID (P = Production)
		Do pTarget.SetValueAt("2.5", "MSH:12")
		
		#; Message Acknowledgment (MSA) and Query Acknowledgment (QAK)
		If pSource.Results.Count() {
			Do pTarget.SetValueAt("AA", "MSA:1")
			Do pTarget.SetValueAt("OK", "QAK:2")
		}
		Else {
			Do pTarget.SetValueAt("AA", "MSA:1")
			Do pTarget.SetValueAt("NF", "QAK:2")
		}
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("QPD:2"), "QAK:1")
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:10"), "MSA:2")
		
		#; Query Parameter Definition (QPD)
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("QPD"), "QPD")
		
		Set tQueriedIdentifier = pOriginalRequest.GetValueAt("QPD:3(1).1")
		Set tQueriedAssigningAuthorityOID = pOriginalRequest.GetValueAt("QPD:3(1).4.2")
		
		#; Patient Identification (PID)
		Kill tIDs
		Set tAffinityDomainOID = ##class(HS.Data.OIDMap).GetOIDForCode(..AffinityDomain)
		Set tFieldNo = 0
		If pSource.Results.Count()=1 && (pSource.Results.GetAt(1).%IsA("HS.Message.IHE.PatientSearchMatch")) {
			Set tResultItem = pSource.Results.GetAt(1)
			For tIdx = 1:1:tResultItem.IDs.Count() {
				Set tMatch = tResultItem.IDs.GetAt(tIdx)
				Set tAA=tMatch.AssigningAuthority
				Set tMRN=tMatch.MRN
				Set tAssigningAuthorityOID = ##class(HS.Data.OIDMap).GetOIDForCode(tAA)
				If tMRN=tQueriedIdentifier,tAssigningAuthorityOID=tQueriedAssigningAuthorityOID continue
				If $i(tFieldNo)
				Do pTarget.SetValueAt(tMatch.MRN, "PID:3("_tFieldNo_").1")
				Do pTarget.SetValueAt(tAA, "PID:3("_tFieldNo_").4.1")
				Do pTarget.SetValueAt(tAssigningAuthorityOID, "PID:3("_tFieldNo_").4.2")
				Do pTarget.SetValueAt("ISO", "PID:3("_tFieldNo_").4.3")
				Do pTarget.SetValueAt("PI", "PID:3("_tFieldNo_").5")
			}
			Do pTarget.SetValueAt("S", "PID:5(2).7")

		} elseif pSource.Results.Count() {
			For i = 1:1:pSource.MPIIDList.Count() {
				If pSource.MPIIDList.GetAt(i).MPIID=tQueriedIdentifier,tAffinityDomainOID=tQueriedAssigningAuthorityOID continue
				If $i(tFieldNo)
				Do pTarget.SetValueAt(pSource.MPIIDList.GetAt(i).MPIID, "PID:3("_tFieldNo_").1")
				Do pTarget.SetValueAt(..AffinityDomain, "PID:3("_tFieldNo_").4.1")
				Do pTarget.SetValueAt(tAffinityDomainOID, "PID:3("_tFieldNo_").4.2")
				Do pTarget.SetValueAt("ISO", "PID:3("_tFieldNo_").4.3")
				Do pTarget.SetValueAt("PI", "PID:3("_tFieldNo_").5")
			}
			For i = 1:1:pSource.Results.Count() {
				Set tAssigningAuthorityCode = pSource.Results.GetAt(i).AssigningAuthority
				Set tAssigningAuthorityOID = ##class(HS.Data.OIDMap).GetOIDForCode(tAssigningAuthorityCode)
				Set tMRN = pSource.Results.GetAt(i).MRN
				If tAssigningAuthorityCode=""!(tMRN="") continue
				If tMRN=tQueriedIdentifier,tAssigningAuthorityOID=tQueriedAssigningAuthorityOID continue
				If $Data(tIDs(tMRN,tAssigningAuthorityCode)) continue
				Set tIDs(tMRN,tAssigningAuthorityCode)=""
				If $i(tFieldNo)
				Do pTarget.SetValueAt(tMRN, "PID:3("_tFieldNo_").1")
				Do pTarget.SetValueAt(tAssigningAuthorityCode, "PID:3("_tFieldNo_").4.1")
				Do pTarget.SetValueAt(tAssigningAuthorityOID, "PID:3("_tFieldNo_").4.2")
				Do pTarget.SetValueAt("ISO", "PID:3("_tFieldNo_").4.3")
				Do pTarget.SetValueAt("MR", "PID:3("_tFieldNo_").5")
			}
			Do pTarget.SetValueAt("S", "PID:5(2).7")
		}
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

Method HL7ErrorResponse(pOriginalRequest As EnsLib.HL7.Message, Output pTarget As EnsLib.HL7.Message) As %Status
{
	Set tSC = $$$OK
	
	Try {
		#; Instantiate target message
		Set pTarget = ##class(EnsLib.HL7.Message).%New()
				
		#; Force the document type assignment on the target, based on the original request document type.
		If pOriginalRequest.DocType["ADT" {
			Set pTarget.DocType = "2.3.1:ACK"
			Set tMessageCode = "ACK"
			Set tTriggerEvent = pOriginalRequest.GetValueAt("MSH:9.2")
			Set tMessageStructure = "ACK"
			Set tVersionID = "2.3.1"
		} Else {
			Set pTarget.DocType = "2.5:RSP_K23"
			Set tMessageCode = "RSP"
			Set tTriggerEvent = "K23"
			Set tMessageStructure = "RSP_K23"
			Set tVersionID = "2.5"
		}
		
		#; Message Header (MSH)
		Do pTarget.SetValueAt(tMessageCode, "MSH:9.1")
		Do pTarget.SetValueAt(tTriggerEvent, "MSH:9.2")
		Do pTarget.SetValueAt(tMessageStructure, "MSH:9.3")
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:5.1"), "MSH:3.1") // Sending Application
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:6.1"), "MSH:4.1") // Sending Facility
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:3.1"), "MSH:5.1") // Receiving Application
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:4.1"), "MSH:6.1") // Receiving Facility
		Do pTarget.SetValueAt($Translate($ZDateTime($Horolog, 3), "-: ", ""), "MSH:7.1") // Message Date/Time
		Do pTarget.SetValueAt(##class(HS.IHE.Util).GetIdForHL7(),"MSH:10") // Message Control ID
		Do pTarget.SetValueAt("P","MSH:11") // Processing ID (P = Production)
		Do pTarget.SetValueAt(tVersionID, "MSH:12")
		
		#; For now just use the first error to populate MSA and QAK.
		Set tErrorCode = ..Errors.Errors.GetAt(1).Code
		Set tAckCode = $Select(tErrorCode>199&(tErrorCode<204):"AR",1:"AE")
		
		#; Message Acknowledgment (MSA) and Query Acknowledgment (QAK)
		Do pTarget.SetValueAt(tAckCode, "MSA:1")
		If pOriginalRequest.GetValueAt("QPD:2")'="" {
			Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("QPD:2"), "QAK:1")
		} ElseIf pOriginalRequest.GetValueAt("MSH:10")'="" {
			Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:10"), "QAK:1")
		}
		Do pTarget.SetValueAt(tAckCode, "QAK:2")
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("MSH:10"), "MSA:2")
		
		#; Query Parameter Definition (QPD)
		Do pTarget.SetValueAt(pOriginalRequest.GetValueAt("QPD"), "QPD")
		
		/*
		For i = 1:1:..Errors.Errors.Count() {
			Set tLoc = ..Errors.Errors.GetAt(i).Location
			If tLoc'="" {
				Set tSegID = $Piece($Piece(tLoc,":",1),"(",1)
				Set tSegSQ = $Piece($Piece($Piece(tLoc,":",1),"(",2),")",1)
				If tSegSQ="" Set tSegSQ = 1
				Set tFldPos = $Piece($Piece(tLoc,":",2),"(",1)
				Set tFldRep = $Piece($Piece($Piece(tLoc,":",2),"(",2),")",1)
				Do pTarget.SetValueAt(tSegID, "ERR("_i_"):2.1")
				Do pTarget.SetValueAt(tSegSQ, "ERR("_i_"):2.2")
				Do pTarget.SetValueAt(tFldPos, "ERR("_i_"):2.3")
				Do pTarget.SetValueAt(tFldRep, "ERR("_i_"):2.4")
			}
			Do pTarget.SetValueAt(..Errors.Errors.GetAt(i).Code, "ERR("_i_"):3")
			Do pTarget.SetValueAt(..Errors.Errors.GetAt(i).Severity, "ERR("_i_"):4")
			Set tDesc = ..Errors.Errors.GetAt(i).Description
			If tDesc'="" {
				Set tDesc = $Translate(tDesc,pTarget.Separators,$Extract("          ",1,$Length(pTarget.Separators)))
				Do pTarget.SetValueAt(tDesc, "ERR("_i_"):5")
			}
		}
		*/
		
		#; The PDQv2 spec seems to imply that multiple ERR segments should
		#; be supported (ITI TF Vol2a Rev 9.0 page 161 paragraph 4265), but
		#; document type RSP_K21 supports only a single ERR segment.  So
		#; return only the first error in the collection.
		If $Piece(pTarget.DocType,":",1)'="" {
			Set tLoc = ..Errors.Errors.GetAt(1).Location
			If $Piece(pTarget.DocType,":",1)'="2.3.1" {
				// Generate HL7v2.5 ERR segment
				If tLoc'="" {
					Set tSegID = $Piece($Piece(tLoc,":",1),"(",1)
					Set tSegSQ = $Piece($Piece($Piece(tLoc,":",1),"(",2),")",1)
					If tSegSQ="" Set tSegSQ = 1
					Set tFldPos = $Piece($Piece($Piece(tLoc,":",2),"(",1),".",1)
					Set tFldRep = $Piece($Piece($Piece(tLoc,":",2),"(",2),")",1)
					If tFldRep="" Set tFldRep = 1
					Set tFldSubPos = $Piece($Piece($Piece(tLoc,":",2),"(",1),".",2)
					Do pTarget.SetValueAt(tSegID, "ERR:2.1")
					Do pTarget.SetValueAt(tSegSQ, "ERR:2.2")
					Do pTarget.SetValueAt(tFldPos, "ERR:2.3")
					Do pTarget.SetValueAt(tFldRep, "ERR:2.4")
					If tFldSubPos'="" Do pTarget.SetValueAt(tFldSubPos,"ERR:2.5")
				}
				Do pTarget.SetValueAt(..Errors.Errors.GetAt(1).Code, "ERR:3")
				Do pTarget.SetValueAt(..Errors.Errors.GetAt(1).Severity, "ERR:4")
				Set tDesc = ..Errors.Errors.GetAt(1).Description
				If tDesc'="" {
					Set tDesc = $Translate(tDesc,pTarget.Separators,$Extract("      ",1,$Length(pTarget.Separators)))
					Do pTarget.SetValueAt(tDesc, "ERR:5")
				}
			} ElseIf $Piece(pTarget.DocType,":",1)="2.3.1" {
				// Generate HL7v2.3.1 ERR segment
				If tLoc'="" {
					Set tSegID = $Piece($Piece(tLoc,":",1),"(",1)
					Set tSegSQ = $Piece($Piece($Piece(tLoc,":",1),"(",2),")",1)
					If tSegSQ="" Set tSegSQ = 1
					Set tFldPos = $Piece($Piece($Piece(tLoc,":",2),"(",1),".",1)
					Do pTarget.SetValueAt(tSegID, "ERR:1.1")
					Do pTarget.SetValueAt(tSegSQ, "ERR:1.2")
					Do pTarget.SetValueAt(tFldPos, "ERR:1.3")
				}
				Do pTarget.SetValueAt(..Errors.Errors.GetAt(1).Code, "ERR:1.4.1")
				Set tDesc = ..Errors.Errors.GetAt(1).Description
				If tDesc'="" {
					Set tDesc = $Translate(tDesc,pTarget.Separators,$Extract("      ",1,$Length(pTarget.Separators)))
					Do pTarget.SetValueAt(tDesc, "ERR:1.4.2")
				}
			}
		} 
		
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

Method IDUpdateNotificationToHL7(pEndPointv2 As HS.Registry.Service.Abstract, pSource As HS.Message.PatientSearchMatch, pTarget As EnsLib.HL7.Message) As %Status
{
	Set tSC = $$$OK
	
	Try {
		Set tDateTime = $Translate($ZDateTime($Horolog, 3), "-: ", "")
		
		#; Instantiate target message
		Set pTarget = ##class(EnsLib.HL7.Message).%New()
		
		#; IHE requires 2.5, so force the document type assignment		
		Set pTarget.DocType = "2.5:ADT_A05"
				
		#; Message Header (MSH)
		Do pTarget.SetValueAt("ADT", "MSH:9.1")
		Do pTarget.SetValueAt("A31", "MSH:9.2")
		Do pTarget.SetValueAt("ADT_A05", "MSH:9.3")
		
		// Don't set MSH:3.1 (Sending Application) or MSH:4.1 (Sending Facility) here, let the PIXv2NotificationOperations do it.
		
		Do pTarget.SetValueAt(pEndPointv2.OIDMapCode.GetAt("ReceivingApplication"), "MSH:5.1") // Receiving Application
		Do pTarget.SetValueAt(pEndPointv2.OIDMapCode.GetAt("ReceivingFacility"), "MSH:6.1") // Receiving Facility
		Do pTarget.SetValueAt(tDateTime, "MSH:7.1") // Message Date/Time
		Do pTarget.SetValueAt($system.Util.CreateGUID(),"MSH:10") // Message Control ID (GUID)
		Do pTarget.SetValueAt("P","MSH:11") // Processing ID (P = Production)
		Do pTarget.SetValueAt("2.5", "MSH:12")
		
		#; Event (EVN)
		Do pTarget.SetValueAt("A31", "EVN:1")
		Do pTarget.SetValueAt(tDateTime, "EVN:2")
		Do pTarget.SetValueAt(tDateTime, "EVN:6")
		
		#; Patient Identification (PID)
		Kill tIDs
		Set tFieldNo = 0
		For i = 1:1:pSource.Identifiers.Count() {
			Set tIdentifier = pSource.Identifiers.GetAt(i)
			Set tAssigningAuthorityCode = tIdentifier.Root
			Set tAssigningAuthorityOID = ##class(HS.Data.OIDMap).GetOIDForCode(tAssigningAuthorityCode)
			Set tMRN = tIdentifier.Extension
			If tAssigningAuthorityCode=""!(tMRN="") continue
			If $Data(tIDs(tMRN,tAssigningAuthorityCode)) continue
			Set tIDs(tMRN,tAssigningAuthorityCode)=""
			Set tIdentifierType=tIdentifier.Use
			If tIdentifierType="" {
				Set tSC = ##class(HS.IHE.Util).AAIdentifierTypeForCode(tAssigningAuthorityCode,.tIdentifierType,..ExcludeIdentifierTypes)
			}
			If tAssigningAuthorityCode = ..AffinityDomain Set tIdentifierType = "PI"
			If tIdentifierType'="" {
				If $i(tFieldNo)
				Do pTarget.SetValueAt(tMRN, "PID:3("_tFieldNo_").1")
				Do pTarget.SetValueAt(tAssigningAuthorityCode, "PID:3("_tFieldNo_").4.1")
				Do pTarget.SetValueAt(tAssigningAuthorityOID, "PID:3("_tFieldNo_").4.2")
				Do pTarget.SetValueAt("ISO", "PID:3("_tFieldNo_").4.3")
				Do pTarget.SetValueAt(tIdentifierType, "PID:3("_tFieldNo_").5")
			}
		}
		
		#; The spec says to not include demographics. But there
		#; may be receivers who want to receive them anyway.
		Set tSendDemographics = ..NotifyWithDemographics
		If tSendDemographics=0 {
			Do pTarget.SetValueAt(" ", "PID:5")
		} Else {
			Do pTarget.SetValueAt(pSource.LastName, "PID:5.1")
			Do pTarget.SetValueAt(pSource.FirstName, "PID:5.2")
			Do pTarget.SetValueAt(pSource.MiddleName, "PID:5.3")
			If pSource.DOB'="" Do pTarget.SetValueAt($Translate($ZDateTime(pSource.DOB, 3), "-: ", ""), "PID:7")
			Do pTarget.SetValueAt(pSource.Sex, "PID:8")
			Set tAddress = pSource.Addresses.GetAt(1)
			If $IsObject(tAddress) {
				Do pTarget.SetValueAt(tAddress.StreetLine, "PID:11.1")
				Do pTarget.SetValueAt(tAddress.City, "PID:11.3")
				Do pTarget.SetValueAt(tAddress.State, "PID:11.4")
				Do pTarget.SetValueAt(tAddress.PostalCode, "PID:11.5")
				Do pTarget.SetValueAt(tAddress.Country, "PID:11.6")
			}
		}
		
		Do pTarget.SetValueAt("N", "PV1:2")
		
	} Catch eException {
		Set tSC = eException.AsStatus()
		Do ..Errors.logError("207","E",$system.Status.GetErrorText(tSC))
	}
	
	Quit tSC
}

/// AddUpdateGetValueAt is used only by the PIXv2 add and update
/// transactions, to provide for using double double quote to
/// blank out demographics fields.
/// This method can be called for multi-valued fields (e.g., "PID:3(1).4").
ClassMethod AddUpdateGetValueAt(pSource As EnsLib.HL7.Message, pField As %String) As %String
{
	
	Set tValue = ""
	
	Try {
		Set tPrimary = $Piece(pField,".",1)
		Set tValue = pSource.GetValueAt(tPrimary)
		If tValue="""""" Set tValue=""
		If pField=tPrimary!($Piece(pField,".",2,3)="1") Quit
		Set tValue = pSource.GetValueAt(pField)
		If tValue="""""" Set tValue=""
	} Catch eException {
		Set tValue = ""
	}
	
	Quit tValue
}

/// Convert the address use field from HL7v2 code (which is what the incoming PIX message will use) to HL7v3 code (which is what we use for HS.Types.Address).<br>
/// If the HL7v2 code has no HL7v3 code analog, default to an address use type of "H" for home address.
ClassMethod ConvertAddressUse(pUse As %String) As %String
{
	If (pUse=""""""){
		Set tConvertedUse=""
		Quit tConvertedUse
	}
	//"BDL", "BR", "F", "N" will all convert to "H" as a default, as will a blank or unsupported use code
	Set tConvertedUse = $Case(pUse,"B":"WP","BA":"BAD","C":"TMP","H":"H","L":"H","M":"ML","P":"H","O":"WP",:"H")
	Quit tConvertedUse
}

Method ValidateOIDAndCode(pHL7Message, pPath As %String, pMatchCode As %Boolean, pType As %String, ByRef pCode As %String, ByRef pOID As %String)
{
	// ITI TF Vol2a Section 3.8.4.1.2.3
	// Assigning Authority may have code and oid and universal type,
	// or just code, or just oid and universal type.  If code and
	// oid are populated then they must reference the same thing.
	
	// HL7 NamespaceID
	Set pCode = pHL7Message.GetValueAt(pPath_".4.1")
	// HL7 UniversalID
	Set pOID = pHL7Message.GetValueAt(pPath_".4.2")
	// HL7 UniversalIDType
	Set tUIT = pHL7Message.GetValueAt(pPath_".4.3")
	
	Set tCodeFromRegistry = ##class(HS.Data.OIDMap).GetCodeForOID(pOID, "")
	
	If (pCode="")&&(pOID="") {
		Do ..Errors.logError("101","E","Missing "_pType, pPath_".4.2")
		
	} ElseIf (pCode'="")&&(pOID'="") {
		If tCodeFromRegistry="" {
			Do ..Errors.logError("204","E","Unknown "_pType_" "_pOID, pPath_".4.2")
		} Else {
			If pMatchCode {
				If $ZConvert(tCodeFromRegistry,"U")=$ZConvert(pCode,"U") {
					Set pCode = tCodeFromRegistry
				} Else {
					Do ..Errors.logError("204","E","Unknown "_pType_" "_pCode, pPath_".4.1")
				}
			} Else {
				Set pCode = tCodeFromRegistry
			}
		}
		If tUIT="" {
			Do ..Errors.logError("101","E","Missing Universal ID Type", pPath_".4.3")
		} ElseIf tUIT'="ISO" {
			Do ..Errors.logError("101","E","Invalid Universal ID Type", pPath_".4.3")
		}
		
	} ElseIf (pCode="")&&(pOID'="") {
		If tCodeFromRegistry="" {
			Do ..Errors.logError("204","E","Unknown "_pType_" "_pOID, pPath_".4.2")
		} ElseIf pCode="" {
			Set pCode = tCodeFromRegistry
		}
		If tUIT="" {
			Do ..Errors.logError("101","E","Missing Universal ID Type", pPath_".4.3")
		} ElseIf tUIT'="ISO" {
			Do ..Errors.logError("101","E","Invalid Universal ID Type", pPath_".4.3")
		}
		
	} ElseIf (pCode'="")&&(pOID="") {
		Set pOID = ##class(HS.Data.OIDMap).GetOIDForCode(pCode, "")
		If pOID="" {
			Do ..Errors.logError("101","E","Unknown "_pType_" "_pCode, pPath_".4.1")
		}
	}
	
	Quit
}

Storage Default
{
<Data name="ProcessDefaultData">
<Subscript>"Process"</Subscript>
<Value name="1">
<Value>MPIOperations</Value>
</Value>
<Value name="2">
<Value>PIXv3ManagerOperations</Value>
</Value>
<Value name="3">
<Value>DeviceID</Value>
</Value>
<Value name="4">
<Value>EDGEIHE</Value>
</Value>
<Value name="5">
<Value>HubOperations</Value>
</Value>
<Value name="6">
<Value>IHEVersion</Value>
</Value>
<Value name="7">
<Value>PIXv3Operations</Value>
</Value>
<Value name="8">
<Value>DefaultAssigningAuthority</Value>
</Value>
<Value name="9">
<Value>TraceOperations</Value>
</Value>
<Value name="10">
<Value>IHEExtension</Value>
</Value>
<Value name="11">
<Value>Transformer</Value>
</Value>
<Value name="12">
<Value>XDSbOperations</Value>
</Value>
<Value name="13">
<Value>AffinityDomain</Value>
</Value>
<Value name="14">
<Value>InternalMPI</Value>
</Value>
<Value name="15">
<Value>AffinityDomainIsMPIID</Value>
</Value>
<Value name="16">
<Value>HUB</Value>
</Value>
<Value name="17">
<Value>DynamicAssigningAuthorityRegistration</Value>
</Value>
<Value name="18">
<Value>DynamicFacilityRegistration</Value>
</Value>
<Value name="19">
<Value>Errors</Value>
</Value>
<Value name="20">
<Value>ExcludeSenders</Value>
</Value>
<Value name="21">
<Value>TransformPIXToPatientSearch</Value>
</Value>
<Value name="22">
<Value>TransformMatchToUpdateNotification</Value>
</Value>
<Value name="23">
<Value>TransformPIXToAddUpdateHubRequest</Value>
</Value>
<Value name="24">
<Value>TransformToMCCI</Value>
</Value>
<Value name="25">
<Value>TransformPatientSearchResponseToPIX</Value>
</Value>
<Value name="26">
<Value>TransformPIXToMergePatientRequest</Value>
</Value>
<Value name="27">
<Value>PIXv2Operations</Value>
</Value>
<Value name="28">
<Value>NotifyWithDemographics</Value>
</Value>
<Value name="29">
<Value>ApplyConsent</Value>
</Value>
<Value name="30">
<Value>ExcludeIdentifierTypes</Value>
</Value>
<Value name="31">
<Value>MatchCodeWithOID</Value>
</Value>
</Data>
<Data name="ValueSet">
<Attribute>ValueSet</Attribute>
<Structure>subnode</Structure>
<Subscript>"HS.IHE.PIXv3.Manager.Process.ValueSet"</Subscript>
</Data>
<DefaultData>ProcessDefaultData</DefaultData>
<Type>%Storage.Persistent</Type>
}

}
