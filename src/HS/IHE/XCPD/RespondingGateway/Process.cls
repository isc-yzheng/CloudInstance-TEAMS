Include (HS.IHE.XCPD, HS.IHE.ATNA, HS.HC)

Class HS.IHE.XCPD.RespondingGateway.Process Extends (Ens.BusinessProcess, HS.HC.Util.Trace.Helper) [ ClassType = persistent, Inheritance = left ]
{

Parameter HSDEPLOY = 1;

Parameter DOMAIN = "HS";

Parameter SETTINGS = "MaxReturnPatientCount:Basic,PDQv3Supplier,XCPDRespondingGatewayOperations,IHEVersion,AffinityDomain,XCPDRespondingGatewayServiceNames,PDQLowThreshold,CacheIDs,ApplyConsent,PRPAINToPatientSearchTransform,QueryResponsesToXCPDResponseTransform,PatientSearchResponseToPRPAINTransform,NationalPatientIdentifier";

/// The Supplier on the BUS will point to the Supplier operation (going to the registry)
Property PDQv3Supplier As Ens.DataType.ConfigName [ InitialExpression = "HS.IHE.PDQv3.Consumer.Operations" ];

/// Since XCPD relies on an exact match, pass the low threshold to the supplier which would evaluate as an exact match.
Property PDQLowThreshold As %String;

Property AffinityDomain As %String;

/// In a National Identifier situation, the National Identifier is sent to the responding gateway instead of demographics.  Locate <br>
/// the MPIID and return it (no demographics) 
Property NationalPatientIdentifier As %Boolean [ InitialExpression = 0 ];

/// Config registry value for \IHE\NationalPatientIdentifierAA
Property NationalPatientIdentifierAA As %String [ InitialExpression = {##class(HS.Registry.Config).GetKeyValue("\IHE\NationalPatientIdentifierAA")} ];

Property MaxReturnPatientCount As %Integer [ InitialExpression = 1 ];

/// If true, patient search requests generated by this process will be processed by consent.
Property ApplyConsent As %Boolean [ InitialExpression = 0 ];

/// Registry Service names of other XCPD responding gateways to send the original request
/// Example: NY State Big Bus needs to federate the XCPD Responding GW request to multiple systems
/// if using XCPDRespondingGatewayServiceNames the PDQv3Supplier will not be used
Property XCPDRespondingGatewayServiceNames As %String(MAXLEN = "");

/// Used for asynchronous responses and when federating the requests (see XCPDRespondingGatewayServiceNames)
Property XCPDRespondingGatewayOperations As Ens.DataType.ConfigName [ InitialExpression = "HS.IHE.XCPD.RespondingGateway.Operations" ];

Property IHEVersion As %Integer [ InitialExpression = 1 ];

Property Errors As HS.Types.IHE.Errors;

Property Transformer As HS.Util.XSLTTransformer;

Property PRPAINToPatientSearchTransform As %String(MAXLEN = 250) [ InitialExpression = "IHE/XCPD/Version1/PRPAIN201305UVToPatientSearchRequest.xsl" ];

Property QueryResponsesToXCPDResponseTransform As %String(MAXLEN = 250) [ InitialExpression = "IHE/XCPD/Version1/QueryResponsesToXCPDResponse.xsl" ];

Property PatientSearchResponseToPRPAINTransform As %String(MAXLEN = 250) [ InitialExpression = "IHE/XCPD/Version1/PatientSearchResponseToPRPAIN201306UV.xsl" ];

/// CacheIDs enables the caching of patient IDs into a Cach&eacute; global for later reference by the XCA Responding Gateway business process.
Property CacheIDs As %Boolean [ InitialExpression = 0 ];

Method OnRequest(pRequest As HS.Message.XMLMessage, Output pResponse As HS.Message.XMLMessage) As %Status
{
	Set tSC=$$$OK
	try {
		If ..NationalPatientIdentifier {
			If ..NationalPatientIdentifierAA = "" {
				Return $$$ERROR($$$Text("Configuration registry for \IHE\NationalPatientIdentifierAA must have a value when NationalPatientIdentifier is true"))
			}
		}
		$$$GetTransformer(..Transformer)
		Set ..Errors=##class(HS.Types.IHE.Errors).%New()
		Set tAction=pRequest.AdditionalInfo.GetAt("SOAPAction"),tIsAsync=0
		Set tReplyTo = pRequest.AdditionalInfo.GetAt("ReplyAddress")
		if tReplyTo]"" Set tIsAsync=1

		Set pResponse=##class(HS.Message.XMLMessage).%New()
		If pRequest.Name = $$$XCPDPatientDiscoveryRequest  {
			Set pResponse.Name=$$$XCPDPatientDiscoveryResponse
			If ..XCPDRespondingGatewayServiceNames]"" {
				Set tSC = ..FederateQueryRequest(pRequest,.pResponse)
			} Else {
				Set tSC=..QueryRequest(pRequest,.pResponse)
			}
			Do $$$ATNAEvent("XCPDRespondingGateway",pRequest,pResponse,tSC)
			//Do ##class(HS.IHE.ATNA.SecureApplication.Utils).CreateAuditEvent(pRequest,..%ClassName(1))
			
			If ..CacheIDs=1 {
				#; For each patient id to return, log it in the caching global.
				#; ^HS.IHE.XCPDCache(patientIdinISOformat, sendingCommunityOID) = $Horolog
				#;
				#; receiver in the response is the same as the sender in the request.
				#; Use the response object for getting the sending community Id, to
				#; save the overhead of instantiating a second document object for
				#; GetXPathValue.
				#;
				#; tSendingCommunityId = OID of the home community that sent the request.
				#; tRoot               = assigning authority OID of a found patient id.
				#; tExtension          = value of a found patient id.
				Set ttSC = ##class(HS.IHE.Util).GetXPathValue(pResponse.ContentStream,"/hl7:PRPA_IN201306UV02/hl7:receiver/hl7:device/hl7:asAgent/hl7:representedOrganization/hl7:id","@root",.tSendingCommunityId,.tDocObject)
				If $Get(tSendingCommunityId)'="" {
					For i = 1:1 {
						Set ttSC = ##class(HS.IHE.Util).GetXPathValue(pResponse.ContentStream,"/hl7:PRPA_IN201306UV02/hl7:controlActProcess/hl7:subject["_i_"]/hl7:registrationEvent/hl7:subject1/hl7:patient/hl7:id","@root",.tRoot,.tDocObject)
						If $Get(tRoot)="" Quit
						Set ttSC = ##class(HS.IHE.Util).GetXPathValue(pResponse.ContentStream,"/hl7:PRPA_IN201306UV02/hl7:controlActProcess/hl7:subject["_i_"]/hl7:registrationEvent/hl7:subject1/hl7:patient/hl7:id","@extension",.tExtension,.tDocObject)
						If $Get(tExtension)="" Quit
						If $Data(^HS.IHE.XCPDCache(tExtension_"^^^&"_tRoot_"&ISO", tSendingCommunityId))#10=0 Set ^HS.IHE.XCPDCache(tExtension_"^^^&"_tRoot_"&ISO", tSendingCommunityId) = $Horolog
					}
					Do pResponse.ContentStream.Rewind()
				}
			}
			
			$$$HSTRACE("response","pResponse",pResponse)
			$$$ThrowOnError(tSC)
		} Else {
			$$$ThrowStatus($$$ERROR($$$GeneralError,"Unhandled request type"))
		}


		If tIsAsync {
			Set tRequest = pResponse
			Set tRequest.Name = $$$XCPDPatientDiscoveryResponse
			Do tRequest.AdditionalInfo.SetAt(pRequest.AdditionalInfo.GetAt("RelatesTo"),"RelatesTo")
			Do tRequest.AdditionalInfo.SetAt(pRequest.AdditionalInfo.GetAt("ReplyAddress"),"ReplyAddress")
			$$$HSTRACE("sending response to "_pRequest.AdditionalInfo.GetAt("ReplyAddress"))
			Set tEndPoint=##class(HS.Registry.Service.SOAP).EndPointForURL(pRequest.AdditionalInfo.GetAt("ReplyAddress"))
			$$$HSTRACE("End point is "_tEndPoint)
			Set tSC = ..SendRequestSync(..XCPDRespondingGatewayOperations,tRequest,.tResponse)
		}					
	} Catch eException {
		Set tSC=eException.AsStatus()
	}
	Quit tSC
}

/// OnResponse must be overridden here to avoid error upon response from async request.
Method OnResponse(pRequest As Ens.Request, ByRef pResponse As Ens.Response, pCallrequest As Ens.Request, pCallresponse As Ens.Response, pCompletionKey As %String) As %Status
{
	Quit $$$OK
}

Method QueryRequest(pRequest As HS.Message.XMLMessage, Output pResponse As HS.Message.XMLMessage) As %Status
{
	Set tSC=$$$OK
	try {
		
		#; predefine search response stream to handle error case
		Set tSearchResponseStream = ##class(%Stream.GlobalCharacter).%New()
		Set tResultCount = 0
		try {
			$$$HSTRACESTARTCALL
			Set tParams("nationalPatientIdentifierAA") = $S(..NationalPatientIdentifier:..NationalPatientIdentifierAA,1:"")
			Set tSC = ..Transformer.TransformIntoObject(pRequest.ContentStream, ..PRPAINToPatientSearchTransform /*"IHE/XCPD/Version1/PRPAIN201305UVToPatientSearchRequest.xsl"*/ , .tRequest,.tParams,"HS.Message.PatientSearchRequest","PatientSearchRequest")
			$$$HSTRACEENDCALL
			$$$ThrowOnError(tSC)
			#; clear out living subject id from other community
			If '..NationalPatientIdentifier {
				Set (tRequest.MRN,tRequest.AssigningAuthority)=""
			}
			Set:..ApplyConsent tRequest.SearchMode="PIXPDQ_c"
			Set:..PDQLowThreshold]"" tRequest.MinMatchPercentage = ..PDQLowThreshold
			Set tSC = ..SendRequestSync(..PDQv3Supplier,tRequest,.tSearchResponse)
			If $$$ISERR(tSC) Do ..Errors.logError("XCPDRespondingGateway","Error","Problem contacting PDQ supplier") Quit
			$$$HSTRACE("search response","tSC,tSearchResponse",tSC,$g(tSearchResponse))
			Set tResponse = ##class(HS.Message.PatientSearchResponse).%New()
			Set tResultCount=tSearchResponse.ResultsCount
			If tResultCount>..MaxReturnPatientCount Quit
			Set tAffinityDomain = $S(..AffinityDomain="":$$$AffinityDomain,1:..AffinityDomain)
			Set tAffinityDomainOID = $$$AffinityDomainOIDGet(tAffinityDomain)

			For tIdx = 1:1:tSearchResponse.MPIIDList.Count() {
				Set tResultItem=""
				/// Now consistently the same between PDQ and MPI Manager
				Set tResponseItem = tSearchResponse.MPIIDList.GetAt(tIdx),tResult=""
				Set tMPIID = tResponseItem.MPIID
				Set tResultItem = tResponseItem
				If $isobject(tResultItem) {
					Set tResult = ##class(HS.Message.IHE.PatientSearchMatch).%New()
					Set tSC = tResult.CopyFrom(tResultItem,tResult) 
					If $$$ISERR(tSC) {
						Do ..Errors.logError("XCPDRespondingGateway","Error","Error copying result "_$system.Status.GetErrorText(tSC)) 
						Continue
					}
					Set tSourceAddresses=tResultItem.Addresses
					Set tTargetAddresses=tResult.Addresses
					For tIdx3=1:1:tSourceAddresses.Count() {
						Do tTargetAddresses.Insert(tSourceAddresses.GetAt(tIdx3))
					}
					Set tResult.Names=tResultItem.Names
					Set tResult.MothersName=tResultItem.MothersName
					Set tResult.FathersName=tResultItem.FathersName
					Set tResult.SpousesName=tResultItem.SpousesName
					Set tMatch = ##class(HS.Message.IHE.Match).%New()
					Set tMatch.AssigningAuthority=tAffinityDomain
					Set tMatch.MRN = tMPIID
					Do tResult.IDs.Insert(tMatch)
					Do tResponse.Results.Insert(tResult)
					Set tMatch.Facility=""
					$$$HSTRACE("Inserting ","tMatch",tMatch)
				}
			}
			
			Do tResponse.XMLExportToStream(.tSearchResponseStream)
			$$$HSTRACE("Search Response Stream","tSearchResponseStream",tSearchResponseStream)
		} Catch eException {
			Do ..Errors.logError("XCPDRespondingGateway","Error","Error contacting PDQ supplier"_$system.Status.GetErrorText(eException.AsStatus()))
		}
		Set tOutput = ##class(%Stream.GlobalCharacter).%New()
		Do tOutput.Write("<root>")
		Do ..Errors.XMLExportToString(.tErrorString)
		Do tOutput.Write(tErrorString)


		Do tSearchResponseStream.Rewind()
		While 'tSearchResponseStream.AtEnd {
			Do tOutput.Write(tSearchResponseStream.Read())
		}
		Do tOutput.Write("<originalRequest>")
		Do pRequest.ContentStream.Rewind()
		While 'pRequest.ContentStream.AtEnd {
			Do tOutput.Write(pRequest.ContentStream.Read())
		}
		Do tOutput.Write("</originalRequest></root>")
		Do tOutput.Rewind()
		$$$HSTRACE("ResponseStream","tSearchResponseStream",tOutput) Do tOutput.Rewind()

		Set tQueryResponseCode = "OK"
		If (tResultCount = 0) {
			Set tQueryResponseCode = "NF"
		}

		Kill tXSLArguments
		Set tXSLArguments("homeCommunityOID") = $$$HomeCommunityOID
		Set tXSLArguments("messageID") = $System.Util.CreateGUID()
		Set tXSLArguments("creationTime") = ##class(HS.Util.XSLTHelper).timestamp()
		Set tXSLArguments("queryStatus") = tQueryResponseCode
		Set tXSLArguments("XCPD") = "1"
		Set tXSLArguments("ackTypeCode") = $S(..Errors.Errors.Count():"AE",1:"AA")
		Set tXSLArguments("nationalPatientIdentifierAA") = $S(..NationalPatientIdentifier:..NationalPatientIdentifierAA,1:"")
		
		$$$HSTRACESTARTCALL
		Set tSC=..Transformer.Transform(tOutput,..PatientSearchResponseToPRPAINTransform /*"IHE/XCPD/Version1/PatientSearchResponseToPRPAIN201306UV.xsl"*/,.tXCPDResponseStream,.tXSLArguments)
		$$$HSTRACEENDCALL
		$$$HSTRACE("Transform status","tSC",tSC)
		Do pResponse.ContentStream.CopyFrom(tXCPDResponseStream)
		$$$HSTRACE("response","pResponse",pResponse)
		Set pResponse.Name = $$$XCPDPatientDiscoveryResponse

	} Catch eException {
		Set tSC=eException.AsStatus()
		Do ..Errors.logError("XCPDRespondingGateway","Error",$system.Status.GetErrorText(eException.AsStatus()))
		//$$$HSTRACE("Error","text",$zcvt($system.Status.GetErrorText(tSC),"O","XML"))
	}
	If ..Errors.Errors.Count() $$$HSTRACE("Errors","Errors",..Errors)
	Quit tSC
}

/// When running in a Big Bus Model we need to federate the original query out to communities within this state
/// take responses from each community and consolidate into a single XCPD response
Method FederateQueryRequest(pRequest As HS.Message.XMLMessage, Output pResponse As HS.Message.XMLMessage) As %Status
{
	Set tSC=$$$OK

	try {
		Set tQueryResponseCode="NF"	//Return "NF" unless at least one federated request returns "OK"
		Set tQueryResponses = ##class(%Stream.GlobalCharacter).%New()
		Do tQueryResponses.Write("<root><support>")
		While 'pRequest.ContentStream.AtEnd {
			Do tQueryResponses.Write(pRequest.ContentStream.Read())
		}
		Do tQueryResponses.Write("</support>"),pRequest.ContentStream.Rewind()

		Do tQueryResponses.Write("<XCPDQueryResponses xmlns:hl7=""urn:hl7-org:v3"">")

		Set tQuerySystems = ..XCPDRespondingGatewayServiceNames
		Set tQuerySysCount=$S(tQuerySystems="":0,1:$l(tQuerySystems,","))
		For tIdx1 = 1:1:tQuerySysCount {
			Set tQuerySys = $p(tQuerySystems,",",tIdx1)
			Set tRq = ##class(Ens.CallStructure).%New()
			Set tSysEndPoint=##class(HS.Registry.Service.SOAP).EndPointForNameType(tQuerySys,"SOAP")
			Set tRequest=pRequest.%ConstructClone(0)
			Set tRequest.ContentStream = ##class(%Stream.GlobalCharacter).%New()
			Do tRequest.ContentStream.CopyFrom(pRequest.ContentStream)
			Set tRequest.AdditionalInfo = pRequest.AdditionalInfo.%ConstructClone()  ///SAML/User Auth
			Set tRequest.SAMLData = pRequest.SAMLData.%ConstructClone()  ///SAML/User Auth
			Do tRequest.AdditionalInfo.SetAt(tQuerySys,"TargetName")
			Set tRq.Request = tRequest
			Set tRq.TargetDispatchName = ..XCPDRespondingGatewayOperations
			Set tRequestList($i(tRequestList)) = tRq
			$$$HSTRACE("Adding Request","tRq",tRq)
			Set tRq=""
		}

		If $g(tRequestList) Set tSC = ..SendRequestSyncMultiple(.tRequestList, ..FailureTimeout)
		$$$HSTRACE("Sending External Requests","Count,tSC",$g(tQuerySysCount),tSC)
		$$$HSThrowErrors(tSC)

		For tIdx1=1:1:$g(tRequestList) {
			Set tRq = tRequestList(tIdx1)
			Set tRequest = tRq.Request
			Set tResponse = tRq.Response
			Set tResult = tRq.ResponseCode
			If $$$ISERR(tResult){
				Do ..Errors.logError("XCPDRespondingGateway","Warning","Error contacting "_tRequest.AdditionalInfo.GetAt("TargetName")_":" _$System.Status.GetErrorText(tResult))
				Set tPartialResults=1
				$$$HSTRACE("Error contacting "_tRequest.AdditionalInfo.GetAt("TargetName")_": "_$System.Status.GetErrorText(tResult))
				$$$LOGERROR("Error contacting "_tRequest.AdditionalInfo.GetAt("TargetName")_": "_$System.Status.GetErrorText(tResult))
				Continue
			}
			ElseIf (tResponse=$$$NULLOREF) {
				Do ..Errors.logError("XCPDRespondingGateway","Warning","No response from "_tRequest.AdditionalInfo.GetAt("TargetName"))
				Set tPartialResults=1
				$$$HSTRACE("Timed out for "_tRequest.AdditionalInfo.GetAt("TargetName"))
				$$$LOGERROR("Timed out for "_tRequest.AdditionalInfo.GetAt("TargetName"))
				Continue
			}
			ElseIf (tResponse.ContentStream.%IsNull()){
				Do ..Errors.logError("XCPDRespondingGateway","Warning","Empty response from "_tRequest.AdditionalInfo.GetAt("TargetName"))
				Set tPartialResults=1
				$$$HSTRACE("Empty response from "_tRequest.AdditionalInfo.GetAt("TargetName"))
				$$$LOGERROR("Empty response from "_tRequest.AdditionalInfo.GetAt("TargetName"))
				Continue
			}
			Set tHaveSomeResults=1
			Do tQueryResponses.CopyFrom(tResponse.ContentStream)
			Do tQueryResponses.MoveToEnd()
			Do tResponse.ContentStream.Rewind()

			Set tSC = ##class(HS.IHE.Util).GetXPathValue(tResponse.ContentStream,"/hl7:PRPA_IN201306UV02/hl7:controlActProcess/hl7:queryAck/hl7:queryResponseCode","@code",.tResponseCode)
			If $$$ISERR(tSC){
				Do ..Errors.logError("XCPDRespondingGateway","Warning","Cound not find response code in response from source "_tRequest.AdditionalInfo.GetAt("TargetName"))
				$$$HSTRACE("XPath error could not find response code in response from source "_tRequest.AdditionalInfo.GetAt("TargetName"),"tSC",tSC)
				$$$LOGERROR("XPath error could not find response code in response from source "_tRequest.AdditionalInfo.GetAt("TargetName")_": "_$System.Status.GetErrorText(tSC))
				Continue
			}
			Set:tResponseCode="OK" tQueryResponseCode="OK"

		}
		Do tQueryResponses.Write("</XCPDQueryResponses></root>")

		Set tXSLArguments("messageID")="'"_$System.Util.CreateGUID()_"'"
		Set tXSLArguments("creationTime")="'"_##class(HS.Util.XSLTHelper).timestamp()_"'"
		Set tXSLArguments("queryStatus")=tQueryResponseCode

		$$$HSTRACESTARTCALL
		Set tSC=..Transformer.Transform(tQueryResponses,..QueryResponsesToXCPDResponseTransform /*"IHE/XCPD/Version1/QueryResponsesToXCPDResponse.xsl"*/,.tSearchResponse,.tXSLArguments)
		$$$HSTRACEENDCALL
		If '$IsObject(tSearchResponse) || $$$ISERR(tSC) {
			Do ..Errors.logError("XCPDRespondingGateway","Error","Unable to create search response") Quit
			$$$LOGERROR("Unable to create search response")
		}
		Do pResponse.ContentStream.CopyFrom(tSearchResponse)
	} Catch eException {
		Set tSC=eException.AsStatus()
		$$$HSTRACE("Error","tSC",tSC)
	} 
	Quit tSC
}

Storage Default
{
<Data name="ProcessDefaultData">
<Subscript>"Process"</Subscript>
<Value name="1">
<Value>PDQv3Supplier</Value>
</Value>
<Value name="2">
<Value>XCPDRespondingGatewayOperations</Value>
</Value>
<Value name="3">
<Value>PDQv3Consumer</Value>
</Value>
<Value name="4">
<Value>AffinityDomain</Value>
</Value>
<Value name="5">
<Value>HomeCommunity</Value>
</Value>
<Value name="6">
<Value>TraceOperations</Value>
</Value>
<Value name="7">
<Value>IHEVersion</Value>
</Value>
<Value name="8">
<Value>IHEExtension</Value>
</Value>
<Value name="9">
<Value>XCPDRespondingGatewayServiceNames</Value>
</Value>
<Value name="10">
<Value>Errors</Value>
</Value>
<Value name="11">
<Value>PDQLowThreshold</Value>
</Value>
<Value name="12">
<Value>Transformer</Value>
</Value>
<Value name="13">
<Value>MaxReturnPatientCount</Value>
</Value>
<Value name="14">
<Value>CacheIDs</Value>
</Value>
<Value name="15">
<Value>PRPAINToPatientSearchTransform</Value>
</Value>
<Value name="16">
<Value>QueryResponsesToXCPDResponseTransform</Value>
</Value>
<Value name="17">
<Value>PatientSearchResponseToPRPAINTransform</Value>
</Value>
<Value name="18">
<Value>ApplyConsent</Value>
</Value>
<Value name="19">
<Value>NationalPatientIdentifier</Value>
</Value>
<Value name="20">
<Value>NationalPatientIdentifierAA</Value>
</Value>
</Data>
<DefaultData>ProcessDefaultData</DefaultData>
<Type>%Storage.Persistent</Type>
}

}
