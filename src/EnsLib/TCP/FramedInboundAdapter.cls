/* Copyright (c) 2020 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */

Include Ensemble

/// Inbound adapter for framed data over TCP
Class EnsLib.TCP.FramedInboundAdapter Extends (EnsLib.TCP.InboundAdapter, EnsLib.TCP.FramedCommon, EnsLib.TCP.TextLineCommon) [ ClassType = "", ProcedureBlock, System = 4 ]
{

Parameter SERVICEINPUTCLASS = "Ens.StreamContainer";

Parameter SERVICEOUTPUTCLASS = "Ens.StreamContainer";

/// If Discarding badly framed data and SendAcknowledgement is true
/// and Acknowledgement not generated by target of the service
/// then if this setting is false (the default) then return NACK else
/// ignore. 
Property DiscardSilently As %Boolean [ InitialExpression = 0 ];

/// This setting is used to wrap the acknowledgement in the framing
/// specified by MessageFrameStart & MessageFrameEnd. The default is true.
Property AddFramingToAcknowledgement As %Boolean [ InitialExpression = 1 ];

Parameter SETTINGS = "UseFileStream,MessageFrameStart:Additional,MessageFrameEnd:Additional,RemoveFraming:Additional,DiscardDataNotwithinFraming:Additional,DiscardSilently:Additional,AddFramingToAcknowledgement:Additional";

Method OnInit() As %Status
{
	Try {
		Set ..Terminators = ..AsciiOrHexAsChars(..MessageFrameEnd)
		Set ..MessageFrameEndAsChars = ..Terminators
		Set ..MessageFrameStartAsChars = ..AsciiOrHexAsChars(..MessageFrameStart)
	} Catch {}
	Quit ##super()
}

Method OnConnected() As %Status
{
	Set tSC=$$$OK, tQuitErr=1
	Set tCharset=..Charset  Set:$Case($ZCVT(..Charset,"L"),"default":1,"auto":1,:0) tCharset="UTF-8"
	Try {
		Set tSC = ..ReadFramedStream(.tStream,tCharset,..CallInterval,..ReadTimeout,1, .tProcessMessage, .tDiscardedData)
		/* We may have timed out waiting for correct terminator. Want to continue to be able to report */
		Quit:($$$ISERR(tSC)&&'tProcessMessage)
		Set tResponseSize = 0
		If tProcessMessage,'tDiscardedData {
			Do tStream.Rewind()
			Set tSC=..BusinessHost.ProcessInput(tStream,.tResponse)
		} ElseIf tDiscardedData {
			Quit:..DiscardSilently /* Do not send a response */
			Try {
				Set tResponse = ""
				Set:..BusinessHost.SendAcknowledgement tResponse=##Class(%IO.StringStream).%New(..BusinessHost.AckNotOKAsChars)
			} Catch { Set tSC = $$$SystemError}	
		} Else {
			#;No data received this poll
			Quit
		}
		Quit:$$$ISERR(tSC)
		#; Write Response as returned by Service. Can be a String, Ens.StreamContainer, Ens.StringRequest, Ens.StringResponse.

		Try {
			If $IsObject(tResponse) {
				 If tResponse.%IsA("Ens.StreamContainer") {
					 Set tResponse = tResponse.Stream
					 Set tResponseSize = tResponse.Size
				 } ElseIf tResponse.%IsA("Ens.StringContainer")||tResponse.%IsA("Ens.StringRequest")||tResponse.%IsA("Ens.StringResponse") {
				 	Set tResponse = ##Class(%IO.StringStream).%New(tResponse.StringValue)
				 	Set tResponseSize = tResponse.Size
				 } ElseIf tResponse.%IsA("%Stream.Object")||tResponse.%IsA("%IO.I.Stream") {
					Set tResponseSize = tResponse.Size
				}
			} ElseIf (tResponse'="") {
				Set tResponse = ##Class(%IO.StringStream).%New(tResponse)
				Set tResponseSize = tResponse.Size
			}
		} Catch {
			Set tResponseSize=0
		}
		If tResponseSize {
			Set tSC  = ..WriteFramedStream(tResponse,tCharset,1,..AddFramingToAcknowledgement)
		}
	} Catch { Set tSC = $$$SystemError}
	#; Returning error status would cause this listener job to terminate
	If $$$ISERR(tSC) {
		#; Never quit the listener, but drop the connection on unrecognized error
		If tQuitErr,..Connected,..StayConnected { 
			$$$LOGERROR("Disconnecting due to "_$$$StatusDisplayString(tSC))
			Set tSC=$$$OK
			Do ..Disconnect()
		}
		If $$$ISERR(tSC) $$$LOGSTATUS(tSC)
	}
	Quit $$$OK
}

Method Disconnect()
{
	Do ##super()
}

}
