/* Copyright (c) 2020 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */

Class EnsLib.MsgRouter.RoutingEngine Extends Ens.BusinessProcess [ ClassType = persistent, ProcedureBlock, System = 4 ]
{

/// Business Rule Name.  If this setting is empty, then the ConfigItem name is used as the rule name
Property BusinessRuleName As %String(MAXLEN = 1000) [ Transient ];

/*
	Validation: a string specifying types of validation to perform; If you override OnValidate() and need to provide
	options, you can add more supported values to it and document them by also overriding the definition of this Validation property.
*/
/// Causes  validation to be performed. Default implementation of OnValidate() does nothing; If you override it and want it to be
/// configurable, override this description comment and add Parameter SETTINGS = "Validation"; to your subclass as well.
Property Validation As %String [ Transient ];

/// Send an Alert if validation blocks a message
Property AlertOnBadMessage As %Boolean [ Transient ];

/// Name of the host that should handle messages that validation blocks
Property BadMessageHandler As %String(MAXLEN = 1000) [ Transient ];

/// Names the target(s) from which a response should be forwarded back to the caller, if the caller requested <br>
/// a response. If this value is empty, no reply will be requested from any target. Otherwise, this value is a <br>
/// comma-separated list of target config names. The response returned will be the first one that arrives back <br>
/// from any target in the list. A value of '*' will match any target, so the first response received will be <br>
/// the one returned.<p>
/// If none of the listed targets gets called and the caller requested a response, an empty 'OK' response header <br>
/// will be returned.<p>
/// If the list of targets begins with a '+' character, the responses from all the targets called
/// will be returned as a list of message header IDs in the response header, or an empty 'OK' response header if no responses appear before the timeout expires.<p>
/// If the list of targets begins with a '-' character, all error responses only from any of the targets called <br>
/// will be returned as a list of message header IDs in the response header, or an empty 'OK' response header if no error responses appear before the timeout expires.
Property ResponseFrom As %String(MAXLEN = 1000) [ Transient ];

/// Names a destination or destinations in addition to the caller to which responses will be forwarded.<p>
/// If this value is empty, responses are only returned to the caller. If one or more target config names are listed
/// (separated by commas), each response from this router will be forwarded to each target config item listed.<p>
/// This setting has effect only if ResponseFrom is not empty.
Property ResponseTargetConfigNames As %String(MAXLEN = 1000);

/// Maximum length of time to wait for asynchronous responses before returning a timed-out error response header.
/// A value of -1 means to wait forever; note that a value of 0 is not useful because every response would time out.<p>
/// This setting has effect only if ResponseFrom is not empty.
Property ResponseTimeout As %Numeric(MINVAL = -1) [ InitialExpression = -1, Transient ];

/// Make synchronous calls for 'send' actions. WARNING: this can cause deadlock if another BP is called by something called synchronously from here.<p>
/// This setting is intended to ensure FIFO ordering when this router and the target Operations have PoolSize=1, and ancillary Operations might get 
/// called asynchronously from within a Transform or Operation called from this router.<p>
/// Note that if there are multiple 'send' targets, this setting means they will be called one after another in serial fashion, with the next being called after the previous call completes.<p>
/// Also note that synchronous calls are not subject to the ResponseTimeout setting.
Property ForceSyncSend As %Boolean [ Transient ];

/// Enable this to cause errors returned by a transformation to stop rule evaluation and the error to be handled by Reply Code Actions setting.
Property ActOnTransformError As %Boolean [ InitialExpression = 0 ];

/// Enable this to cause errors returned by validation to be handled by Reply Code Actions setting.
Property ActOnValidationError As %Boolean [ InitialExpression = 0 ];

/// This set of flags controls the logging performed by the rule engine whenever a routing rule is executed.
/// The following flags are available:
/// <ul><li>'e' - log errors only. All errors will be logged irrespective of other flags, so 
/// setting the value to 'e' or leaving the value empty will only log errors.</li>
/// <li>'r' - log return values. This is the default value for the setting, and is 
/// also automatic whenever the 'd' or 'c' flags are specified.</li>
/// <li>'d' - log user-defined debug actions in the rule. This will also include 'r'.</li>
/// <li>'c' - log details of the conditions that are evaluated in the rule. This will also include 'r'.</li>
/// <li>'a' - log all available information. This is equivalent to 'rcd'.</li></ul>
Property RuleLogging As %String [ InitialExpression = {$$$eRuleLogTypeReturn} ];

Parameter SETTINGS = "BusinessRuleName:Basic:ruleSelector,AlertOnBadMessage,BadMessageHandler::selector?context={Ens.ContextSearch/ProductionItems?targets=1&productionName=@productionId},ResponseFrom::selector?multiSelect=1&context={Ens.ContextSearch/ProductionItems?targets=1&productionName=@productionId},ResponseTargetConfigNames::selector?multiSelect=1&context={Ens.ContextSearch/ProductionItems?targets=1&productionName=@productionId},ResponseTimeout,ForceSyncSend,ActOnTransformError,ActOnValidationError,RuleLogging:Dev";

Property Document As %RegisteredObject [ Transient ];

Property Source As %String(MAXLEN = 128) [ Transient ];

Property MsgClass As %String(MAXLEN = 128) [ Transient ];

Property ActionTargets As %String(MAXLEN = "") [ Transient ];

Property aRespFrom As array Of %String(MAXLEN = 128);

/// Should we wait for all responses?
Property %WaitAll As %String(MAXLEN = 1);

/// List of responses we have gotten that we are going to send back
Property %ResponseList As list Of %String(MAXLEN = "");

/// Did we time out while waiting for any response(s)?
Property %TimedOut As %Boolean;

/// Remember the error we return in OnError() so we can use it in OnComplete() if needed
Property %ErrorStatus As %Status [ InitialExpression = {$$$OK}, Transient ];

/// FullReason for RuleSet action
Property RuleReason As %String(MAXLEN = 2000, TRUNCATE = 1) [ Transient ];

/// User defined variable that applies to the RuleSet.<br>
/// Only one value of the RuleUserData variable is available and it is the 
/// last value it is assigned in the RuleSet before the RuleSet returns.
Property RuleUserData As %String(MAXLEN = "") [ Transient ];

/// A user defined variable that can be set in a specific rule/when or rule/otherwise action.<br>
/// The value assigned will be paired with the system assigned <property>RuleActionReason<property>
/// value at the time of assignment (using the internal <property>RuleActionUserDataArray<property>).<br>
/// The RuleActionReason value is assigned by the system at the start of each
/// rule/when or rule/otherwise execution if RuleActionUserData is used in the rule.<br>
/// The value of aux.RuleActionUserData accessed in a transformation called from a routing rule as
/// part of a send action will be the value assigned in the routing rule for the particular 
/// rule/when or rule/otherwise that led to the send action.<br>
/// A transformation that is called from a routing rule as part of a send action can set 
/// aux.RuleActionUserData. Any subsequent transformations that are executed as part of a
/// send action from the same rule/when or rule/otherwise will then retrieve the transformation
/// modified value if they access aux.RuleActionUserData.<br>
/// If the RuleActionReason is empty the RuleActionUserData assignment will not take place.<br>
Property RuleActionUserData As %String(MAXLEN = "") [ Transient ];

/// RuleActionReason is not intended for user assignment.<br>
/// This property is only valid if the RuleSet being called includes one or more assignments
/// to the context property <property>RuleActionUserData</property>.<br>
/// If this is the case then the the rule action reason is set at
/// the start of each rule/when or rule/otherwise execution<br>
/// The system assigned value is of the form rule#1when#1 or rule#1otherwise. (numbers change as appropriate).<br>
/// If the rule action reason is set in the rule it is returned as part of a send return value allowing 
/// the Routing Engine to set RuleActionReason property to the value
/// contained in the send return instruction.<br>
/// This allows transformations to access aux.RuleActionUserData which
/// will be the value of the RuleActionUserData set during
/// the particular rule/when or rule/otherwise execution that led to the
/// send transformation action.<br>
/// This property value is reset to empty string at the end of the rule execution.<br>
/// NOTE: If a send action takes place outside of a rule/when or rule/otherwise any value returned
/// with the send instructions will be the last value set in the rule execution.<br>
/// NOTE: This property is only valid if the rule being called is assigning one or more values to
/// the routing engine context property <property>RuleActionUserData<property>.
Property RuleActionReason As %String(MAXLEN = "") [ Transient ];

/// Direct access to this array property is not intended.<br>
/// Internal storage for user defined variables at specific rule/when
/// or rule/otherwise states in the ruleset execution.<br>
/// This property cannot be set directly in the rule.<br>
/// NOTE: This property is only valid if the rule being called is assigning one or more values to
/// the routing engine context property <property>RuleActionUserData<property>.
Property RuleActionUserDataArray As %String(MAXLEN = "") [ MultiDimensional ];

/// Retrieve RuleActionUserData value from array for current RuleActionReason value.
Method RuleActionUserDataGet() As %String [ Internal ]
{
	#dim data = ""
	Try {
		If (i%RuleActionReason'="") Set data = $Get(i%RuleActionUserDataArray(i%RuleActionReason))
	} Catch {}
	Return data
}

/// Store RuleActionUserData value in an array for the current RuleActionReason value.
Method RuleActionUserDataSet(value) As %Status [ Internal ]
{
	Try {
		If (i%RuleActionReason'="") Set i%RuleActionUserDataArray(i%RuleActionReason) = value
	} Catch {}
	Return $$$OK
}

/// Ensure that the value of <property>RuleLogging</property> is normalized at the time that it is set.
Method RuleLoggingSet(pRuleLogging As %String = {$$$eRuleLogTypeReturn}) As %Status
{
	Set i%RuleLogging = ##class(Ens.Rule.Definition).NormalizeRuleLogTypes(pRuleLogging)
	Quit $$$OK
}

/// Override this method to implement your own method for validating a Document
/// Return non-zero to prevent default validation of the message (if any);
/// return an error code in pStatus to indicate a validation failure.
Method OnValidate(pDoc As %Persistent, pValSpec As %String, Output pStatus As %Status = {$$$OK}) As %Boolean
{
	Quit 0
}

Method OnRequest(request As %Persistent, Output response As %Persistent) As %Status
{
	Do:(..Validation'="")&&(..Validation'=0) $this.OnValidate(request,..Validation,.tSCVal) // no default validation
	Set:'$D(tSCVal) tSCVal=$$$OK
	If $$$ISERR(tSCVal) {
		#; Send to bad message handler
		If ..BadMessageHandler'="" {
			Set tSC=..SendRequestAsync(..BadMessageHandler,request,0)  Quit:$$$ISERR(tSC) tSC
		}
		#; Quit without forwarding if the message is bad
		Set tSC=$$$ERROR($$$EnsErrGeneral,"Not forwarding message "_..%PrimaryRequestHeader.%Id()_" with message body Id="_request.%Id()_", Doc Identifier="_request.Identifier_", SessionId="_..%PrimaryRequestHeader.SessionId_" because of validation failure: "_$$$StatusDisplayString(tSCVal))
		Do $this.OnError(request,.response,$$$NULLOREF,tSC,"0_!_Validation")
		Quit $S(..ActOnValidationError:tSC,1:$$$OK)
	}
	#; Build forward and reverse maps of target names from which we expect a response
	Set ..%WaitAll=$Case($E($ZStrip(..ResponseFrom,"<W")),"+":"+","-":"-",:"")
	Set:""'=..%WaitAll ..ResponseFrom=$E(..ResponseFrom,$F(..ResponseFrom,..%WaitAll),*) ; remove prefix if any
	Set tLen=$L(..ResponseFrom,",") For i=1:1:tLen { Set tRF=$ZStrip($P(..ResponseFrom,",",i),"<>W")  Continue:""=tRF
		Do ..aRespFrom.SetAt(tRF,i)
		Do:""=..aRespFrom.GetAt(tRF) ..aRespFrom.SetAt(i,"+"_tRF)
	}
	Set ..Document=request
	Set ..Source = ..%PrimaryRequestHeader.SourceConfigName
	Set ..MsgClass = $classname(request)
	Set tRuleName=..BusinessRuleName  Set:""=tRuleName tRuleName=..%ConfigName
	Quit ..doOneAction(request,"rule:"_tRuleName,,,.response)
}

Method OnResponse(request As %Persistent, ByRef response As %Persistent, callrequest As %Persistent, callresponse As %Persistent, pCompletionKey As %String) As %Status
{
	Quit:..%TimedOut||$$$IsdefObject(response) $$$OK
	Set tKey=$P(pCompletionKey,"_",2)
	Set tFrom=$S(+tKey'=tKey:$P(pCompletionKey,"_",3), 1:..aRespFrom.GetAt(tKey))
	If ""'=tFrom {
		Set tIsObj=$$$IsdefObject(callresponse)
		If ""=..%WaitAll {
			If tIsObj {
				$$$sysTRACE("Returning response "_callresponse.%Id()_" from "_tFrom_" as response from routing BP "_..%Id())
				Set response=callresponse
			}  ; else just exit w/ OK & no response body
			Do ..ClearAllPendingResponses()
		} Else {
			Set tErrType=$S(tIsObj&&..IsErrorResponse(request,callresponse):"NACK ", $$$ISERR(..%ErrorStatus):"error ", 1:"")
			If "+"=..%WaitAll || (""'=tErrType) {
				$$$sysTRACE("Adding "_tErrType_"header "_..%CurrentResponseHeader.%Id()_" to response holding list in routing BP "_..%Id())
				Do ..%ResponseList.Insert(..%CurrentResponseHeader.%Id())
				Set ..%ErrorStatus=$$$OK
			}
		}
	}
	Quit $$$OK
}

Method OnError(request As %Persistent, ByRef response As %Persistent, callrequest As %Persistent, pErrorStatus As %Status, pCompletionKey As %String) As %Status
{
	Quit:$$$IsdefObject(response) $$$OK ; If the response is already set, don't mess with it
	Set tKey=$P(pCompletionKey,"_",2)
	If "!"=tKey { ; validation failure
		$$$ASSERT($P(pCompletionKey,"_",3)="Validation"&&'$IsObject(callrequest))
		If ..AlertOnBadMessage { Do ..SendAlert(##class(Ens.AlertRequest).%New($LB(..%ConfigName,$$$StatusDisplayString(pErrorStatus)))) }
		Else { $$$LOGSTATUS(pErrorStatus) }
		Set ..%ErrorStatus=pErrorStatus
		Quit $$$OK
	} Else {
		Set tFrom=$S(+tKey'=tKey:$P(pCompletionKey,"_",3), 1:..aRespFrom.GetAt(tKey))
		#; we should never get an error from somewhere we didn't request a reply from; if we do just error out
		Quit:""=tFrom pErrorStatus
	}
	If ""=..%WaitAll {
		Do ..ClearAllPendingResponses() ; ensure call to OnComplete
		Set ..%ErrorStatus=pErrorStatus
		Quit ..%ErrorStatus
	} Else {
		#; return OK so it will be caught in OnResponse()
		Set ..%ErrorStatus=pErrorStatus
		Quit $$$OK
	}
}

Method OnTimeout(request As %Persistent, ByRef response As %Persistent, callrequest As %Persistent, pCompletionKey As %String) As %Status
{
	Quit:$$$IsdefObject(response) $$$OK ; If the response is already set, don't mess with it
	Set ..%TimedOut=1
	For tI=..%MasterPendingResponses.Count():-1:1 {
		Set tEntry=..%MasterPendingResponses.GetAt(tI)
		Do ..%MasterPendingResponses.RemoveAt(tI)
		Set tRequestHeader=##class(Ens.MessageHeader).%OpenId($li(tEntry,1))

		Set tHeader = ##class(Ens.MessageHeader).%New()  Quit:'$IsObject(tHeader)
		Set tHeader.SourceConfigName = tRequestHeader.TargetConfigName
		
		Set tHeader.TimeCreated = $$$timeUTC
		Set tHeader.SessionId = tRequestHeader.SessionId

		Set tHeader.Type = $$$eMessageTypeResponse
		Set tHeader.BusinessProcessId = tRequestHeader.BusinessProcessId

		Set tHeader.TargetConfigName = tRequestHeader.SourceConfigName
		Set tHeader.SourceBusinessType = tRequestHeader.TargetBusinessType
		Set tHeader.TargetBusinessType = tRequestHeader.SourceBusinessType
		
		Set tHeader.Status = $$$eMessageStatusCompleted
		
		Set tHeader.IsError=1, tHeader.ErrorStatus=$$$ERROR($$$EnsErrGeneral,"Routing BP "_..%Id()_" timed out waiting for response from "_tRequestHeader.TargetConfigName_" for request "_tRequestHeader.%Id())
		Do tHeader.%Save()
		Do ..%ResponseList.Insert(tHeader.%Id())

		Set tMessageBody=$classmethod(tRequestHeader.MessageBodyClassName,"%OpenId",tRequestHeader.MessageBodyId)
		Set $ZT="UserTrapOnTimeout"
		Do tMessageBody.%OnTimeout()
UserTrapOnTimeout
		Set $ZT=""
	}
	Quit $$$OK
}

Method OnComplete(request As %Persistent, ByRef response As %Persistent) As %Status
{
	#; Only prepares a reply if there's not one already done and if ..ResponseFrom indicated we need one or the caller requires one
	Set tHasTarget=(""'=$ZStrip(..ResponseTargetConfigNames,"*W",","))
	Set tNeedReply=tHasTarget||..%PrimaryRequestHeader.needsReply()
	Do:tNeedReply ..OnPrepareReply(request,.response)
	If ""'=..%WaitAll&&(""=$G(response))&&tNeedReply {
		If ..%ResponseList.Count()||..%TimedOut {
			Set tList="" For i=..%ResponseList.Count():-1:1 {
				Set tList=$LB(..%ResponseList.GetAt(i))_tList
			}
			Set response=tList
		}
	} Do ..%ResponseList.Clear(), ..aRespFrom.Clear() ; clear to reduce storage

	If ""'=$G(response) {
		For i=1:1:$L(..ResponseTargetConfigNames,",") { Set tRT=$ZStrip($P(..ResponseTargetConfigNames,",",i),"<>W")  Continue:""=tRT
			$$$sysTRACE("Forwarding response "_$S($IsObject(response):response.%Id(),1:response)_" to "_tRT_" as response from routing BP "_..%Id())
			Do ..SendRequestAsync(tRT,response,0)
		}
	} Set ..ResponseTargetConfigNames=""  ; clear to reduce storage
	Quit $$$OK
}

Method OnPrepareReply(request As %Persistent, ByRef response As %Persistent)
{
}

Method IsErrorResponse(request As %Persistent, ByRef response As %Persistent) As %Boolean
{
	Quit 0
}

Method doOneAction(pRequest As %Persistent, pOneAction As %String, Output pQuitProcessing As %Boolean, pLevel As %Integer = 1, Output pSyncResponse As %Persistent) As %Status
{
	#dim tRuleReason As %String = ""
	
	Quit:pLevel>1000 $$$EnsError($$$EnsErrGeneral,"Rule "_pOneAction_" recursion level too deep: "_pLevel)
	Set $ZT="Trap", tSC=$$$OK, pQuitProcessing=0

	Set tActionType=$P(pOneAction,":",1)
	Set ..ActionTargets=$P(pOneAction,":",2)
	Set tActionTransform=$TR($P(pOneAction,":",3)," ")
	Set ..RuleActionReason=$P(pOneAction,":",4)

	If tActionType="rule" || (tActionType="delegate") {
		For iTg=1:1:$L(..ActionTargets,",") { Set tOneTarg=$ZStrip($P(..ActionTargets,",",iTg),"<>W")  Continue:""=tOneTarg
			Set tSC=##class(Ens.Rule.RuleDefinition).EvaluateRulesEx(tOneTarg, ..%SessionId, $this, $classname(), .tActionList, .tRuleReason,, ..RuleLogging) Quit:$$$ISERR(tSC)
			Set ..RuleReason = tRuleReason
			Set tActionTotal=$S(tActionList="":0,1:$L(tActionList,";"))
			For i=1:1:tActionTotal {
				Set tSC=..doOneAction(pRequest,$P(tActionList,";",i),.pQuitProcessing,pLevel+1,.pSyncResponse)
				Quit:$$$ISERR(tSC)||pQuitProcessing
			}
		}
	}
	ElseIf tActionType="delete" {
		Set pQuitProcessing=1
		Set tSC=pRequest.%DeleteId(pRequest.%Id())
	}
	ElseIf tActionType="send" {
		Set newrequest=pRequest
		For iTxform=1:1:$L(tActionTransform,",") { Set tXform=$ZStrip($P(tActionTransform,",",iTxform),"<>W")  Continue:""=tXform
			Set tSC=$classmethod(tXform,"Transform",newrequest,.newrequest,$this)  Quit:$$$ISERR(tSC)
		}
		If $$$ISERR(tSC) {
			Set tSC=$$$ERROR($$$EnsErrGeneral,"Not routing to target(s) '"_..ActionTargets_"' because of error in Transform '"_tXform_"' : "_$$$StatusDisplayString(tSC))
			$$$LOGSTATUS(tSC)
			Do:..AlertOnError ..SendAlert(##class(Ens.AlertRequest).%New($LB(..%ConfigName,$$$StatusDisplayString(tSC))))
			Quit $S(..ActOnTransformError:tSC,1:$$$OK) ; don't terminate other rules unless explicitly set to end on error
		} Else {
			For iTg=1:1:$L(..ActionTargets,",") { Set tOneTarg=$ZStrip($P(..ActionTargets,",",iTg),"<>W")  Continue:""=tOneTarg
				Set iTarg=..aRespFrom.GetAt("+"_tOneTarg)
				Set:""=iTarg&&..aRespFrom.GetAt("+*") iTarg="*_"_tOneTarg
				Set tResponseRequired=(""'=iTarg)  set:tResponseRequired iTarg=..%MasterPendingResponses.Count()_"_"_iTarg
				If '..ForceSyncSend {
					If ..ResponseTimeout>0&&..aRespFrom.Count()&&'..ForceSyncSend { Do ..SetTimer(..ResponseTimeout)  Set ..ResponseTimeout=0 }
					Set tSC=..SendRequestAsync(tOneTarg,newrequest,tResponseRequired,iTarg)
				} Else {
					Set tSC=..SendRequestSync(tOneTarg,newrequest,.tResponse)
					Set:$$$ISOK(tSC) ..%CurrentResponseHeader=tResponse, tSC=$method($this,"OnResponse",pRequest,.pSyncResponse,newrequest,tResponse,iTarg)
				}
			}
		}
	} ElseIf $Case(tActionType, "stop":0, "contin":0, :1) {
		Set tSC=$$$EnsError($$$EnsErrGeneral,"Invalid action type: "_tActionType)
	}
	Set ..ActionTargets=""
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
}

ClassMethod OnGetConnections(Output pArray As %String, pItem As Ens.Config.Item)
{
	Do ##super(.pArray,pItem)
	Set (tRuleName,tRespTargs,tBadMessageHandler,tAlertOnBadMessage)=""
	Do pItem.PopulateModifiedSettings()
	Set tIndex = ""
	For {
		Set tOneSetting = pItem.ModifiedSettings.GetNext(.tIndex) Quit:tIndex=""
		Set tName=tOneSetting.Name
		If tName="BusinessRuleName" { Set tRuleName = tOneSetting.Value }
		ElseIf tName="BadMessageHandler" { Set tBadMessageHandler = tOneSetting.Value }
		ElseIf tName="AlertOnBadMessage" { Set tAlertOnBadMessage = tOneSetting.Value }
		ElseIf tName="ResponseTargetConfigNames" { Set tRespTargs = tOneSetting.Value }
	}
	Set:tRuleName="" tRuleName=pItem.Name
	if $g(^Ens.Rule("alias",tRuleName))'="" set tRuleName=^Ens.Rule("alias",tRuleName)
	Set tTargets="" For  {
		Set tTargets=$o(^Ens.Rule.Targets(tRuleName,tTargets)) Quit:tTargets=""
		For i=1:1:$L(tTargets,",") Set one=$ZStrip($P(tTargets,",",i),"<>W")  Continue:""=one  Set pArray(one)=""
	}
	Do ..GetDelegateConnections(.pArray,tRuleName)
	Set:tBadMessageHandler'="" pArray(tBadMessageHandler)=""
	Set:+tAlertOnBadMessage pArray("Ens.Alert")=""
	For i=1:1:$L(tRespTargs,",") Set one=$ZStrip($P(tRespTargs,",",i),"<>W")  Continue:""=one  Set pArray(one)=""
}

ClassMethod GetDelegateConnections(Output pArray As %String, pRuleName As %String, pSeen As %List = "")
{
	Set pSeen = pSeen_$lb(pRuleName)
	Set tDelegate = ""
	For {
		Set tDelegate=$O(^Ens.Rule.Delegates(pRuleName,tDelegate))  Quit:tDelegate=""
		Set tRule = $Select($G(^Ens.Rule("alias",tDelegate))'="":^Ens.Rule("alias",tDelegate),1:tDelegate)
		Set tTargets=""
		For  {
			Set tTargets=$O(^Ens.Rule.Targets(tRule,tTargets)) Quit:tTargets=""
			For i=1:1:$L(tTargets,",") {
				Set one=$ZStrip($P(tTargets,",",i),"<>W")
				Continue:""=one
				Set pArray(one)=""
			}
		}
		Do:'$lf(pSeen,tRule) ..GetDelegateConnections(.pArray,tRule,.pSeen)
	}
}

/// Convert to lower case, with inverse spec chars converted to upper case
ClassMethod normalizeValSpec(pValSpec As %String) As %String
{
	Set pValSpec=$ZCVT(pValSpec,"L")
	Set new="",neg=0 For i=1:1:$L(pValSpec) { Set c=$E(pValSpec,i)
		If "-"=c Set neg='neg  Continue
		Set new=new_$S(neg:$ZCVT(c,"U"),1:c), neg=0
	}
	Quit new
}

Storage Default
{
<Data name="RoutingEngineDefaultData">
<Subscript>"RoutingEngine"</Subscript>
<Value name="1">
<Value>%WaitAll</Value>
</Value>
<Value name="2">
<Value>%ResponseList</Value>
</Value>
<Value name="3">
<Value>%TimedOut</Value>
</Value>
<Value name="4">
<Value>ResponseTargetConfigNames</Value>
</Value>
<Value name="5">
<Value>ActOnTransformError</Value>
</Value>
<Value name="6">
<Value>RuleLogging</Value>
</Value>
<Value name="7">
<Value>ActOnValidationError</Value>
</Value>
</Data>
<Data name="aRespFrom">
<Attribute>aRespFrom</Attribute>
<Structure>subnode</Structure>
<Subscript>"aRespFrom"</Subscript>
</Data>
<DefaultData>RoutingEngineDefaultData</DefaultData>
<Type>%Storage.Persistent</Type>
}

}
