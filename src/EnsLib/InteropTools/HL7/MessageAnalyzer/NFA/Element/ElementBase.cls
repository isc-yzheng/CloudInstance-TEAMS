/* Copyright (c) 2020 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */

Import (EnsLib.InteropTools.HL7.MessageAnalyzer.Match.Lexer, EnsLib.InteropTools.HL7.MessageAnalyzer.NFA, EnsLib.InteropTools.HL7.MessageAnalyzer.NFA.Traverser, EnsLib.InteropTools.HL7.MessageAnalyzer.Shell, EnsLib.InteropTools.HL7.MessageAnalyzer, EnsLib.InteropTools.HL7.MessageAnalyzer.NFA.Control)

Include EnsLib.InteropTools.HL7.MessageAnalyzer.Utils

/// SuccNext and FailNext contain element names
/// This class and those which extend it are used as nodes in the NFA which is generated by Node.Base.GenerateElement
Class EnsLib.InteropTools.HL7.MessageAnalyzer.NFA.Element.ElementBase Extends %RegisteredObject [ Abstract ]
{

Parameter GRAPHPROVENANCE As %Boolean = 0;

/// The unique name of this element
Property ElementName As %String [ ReadOnly ];

/// What created this element
Property Provenance As %List [ ReadOnly ];

/// List of names to branch to if this element succeeds
Property SuccNext As %List [ Private ];

/// List of names to branch to if this element fails
Property FailNext As %List [ Private ];

/// Position of this node in the original source
/// <p> $LB(start,afterend) (1-based)
Property SourceOffset As %List [ ReadOnly ];

Method %OnNew(pMachine As Machine, pPrefix As %String, pProvenance As %List, pSourceOffset As %List) As %Status
{
	Set i%ElementName=pMachine.SetAtWithSerial($This,.pPrefix)
	
	Set i%Provenance=pProvenance
	$$$ACASSERT($ListLength(..Provenance)||1,"Provenance must be a %List") // this will cause an error rather than asserting if the provenance is not a list
	
	Set i%SourceOffset=pSourceOffset
	
	Quit $$$OK
}

/// virtual default
Method CanRemove(pMachine As Machine) As %Boolean [ CodeMode = expression ]
{
0
}

/// virtual default
Method OnMarkingTraversal(Output pMarkSeen, Output pAlias, Output pDontTrim, pMachine As Machine)
{
	$$$SHOULDBEUNDEF(pMarkSeen)
	$$$SHOULDBEUNDEF(pAlias)
	$$$SHOULDBEUNDEF(pDontTrim)
}

/// On success: return $LB(1,$LB(elementname,...)) and update pMSR
/// On failure: return $LB(0,$LB(elementname,...)) and leave pMSR unchanged
Method Accept(pMSR As MessageSegmentReader, pBranchContext As BranchContext) As %List [ Final ]
{
	Quit ..AcceptImpl(pMSR,pBranchContext)
}

/// On success: return $LB(1,$LB(elementname,...)) and update pMSR
/// On failure: return $LB(0,$LB(elementname,...)) and leave pMSR unchanged
Method AcceptImpl(pMSR As MessageSegmentReader, pBranchContext As BranchContext) As %List [ Abstract ]
{
}

/// Default implementation
Method DigraphColor() As %String [ CodeMode = expression ]
{
"blue"
}

/// Default implementation
Method GetContextVar() [ CodeMode = expression ]
{
""
}

/// Return a list - pNextElements(1..*)=ElementBase - of all the elements which can be reached by traversing all paths of the NFA and returning the success-linked nodes of the first node with any failure links
Method NextElements(pControl As ControlBase, Output pNextElements) [ Final ]
{
	$$$SHOULDBEUNDEF(pNextElements)

	Set tTodo($I(tTodo))=$This
	While tTodo 
	{
		Set tElement=tTodo(tTodo) Kill tTodo(tTodo) Set tTodo=tTodo-1
		
		// if there are fail links ..
		If tElement.FailNext'="" {
		
			// return each element pointed to by the success links
			Set tPtrI=0 While $ListNext(tElement.SuccNext,tPtrI,tElemI) {
				Set pNextElements($I(pNextElements))=pControl.GetElement(tElemI)
			}
		}
		
		// .. there are no fail links ..
		Else {
		
			// add each element pointed to by the success links to the todo array
			Set tPtrI=0 While $ListNext(tElement.SuccNext,tPtrI,tElemI) {
				Set tTodo($I(tTodo))=pControl.GetElement(tElemI)
			}
		}
	}
}

/// <p> Set the succ/fail next lists
Method SetNext(pSuccNext As %List, pFailNext As %List, pOverwrite As %Boolean = 0) [ Final ]
{
	$$$ACASSERT(pOverwrite || ((..SuccNext="") && (..FailNext="")),"ElementBase Succ/Next set more than once")
	
	Set ..SuccNext=pSuccNext
	Set ..FailNext=pFailNext
}

Method Depth() As %Integer [ CodeMode = expression, Final ]
{
$ListLength(..Provenance)
}

Method CollectSucc(pFullClassName As %String, pMachine As Machine, Output pSucc) [ Final ]
{
	#Dim tElement As ElementBase
	
	$$$SHOULDBEUNDEF(pSucc)
	
	$$$ACASSERT(..%IsA(pFullClassName),"CollectSucc: start class is not a '"_pFullClassName_"'")
	Set tElement=$This
	Do {
		Set pSucc($I(pSucc))=tElement
		Set tSuccList=tElement.SuccNext
		If $ListLength(tSuccList)'=1 {Quit}
		Set tElement=pMachine.GetAt($List(tSuccList))
	} While tElement.%IsA(pFullClassName)
}

/// List all nodes used in the NFA which are reachable from this element
Method ListAll(pMachine As Machine) [ Final ]
{
	Do ..Traverse(pMachine,##class(ListTraverser).%New(pMachine))
}

/// Traverse all nodes used in the NFA which are reachable from this element
Method Traverse(pMachine As Machine, pTraverser As BaseTraverser) [ Final ]
{
	#Dim tSeen,tTodo,tName,tUnseen,tItemName
	#Dim tList As %List
	#Dim tElement As ElementBase
	
	Kill tSeen,tTodo
	Set tSeen(..ElementName)=""
	Set tTodo(..ElementName)=""
	While $Data(tTodo)\10 {
		Set tName=$Order(tTodo("")) Kill tTodo(tName)
		
		Set tElement=pMachine.GetAt(tName)
		Do pTraverser.Seen(tElement)
		Do add(tElement.SuccNext)
		Do add(tElement.FailNext)
	}
	
	Set tUnseen=""
	Set tName="" While 1 {
		Set tName=pMachine.Next(tName) If tName="" {Quit}
		If '$Data(tSeen(tName)) {
			Set tUnseen=tUnseen_$ListBuild(tName)
		}
	}
	
	If tUnseen'="" {
		Do pTraverser.Unseen(tUnseen)
	}
	
	Do pTraverser.Finalize()
	
	Quit
	
add(tList)
	Set tPtrI=0 While $ListNext(tList,tPtrI,tElemI) {
		If '$Data(tSeen(tElemI)) {
			Set tSeen(tElemI)=""
			Set tTodo(tElemI)=""
		}
	}
	Quit
}

/// For use by traversers
Method GetSucc() As %List [ CodeMode = expression, Final ]
{
..SuccNext
}

/// For use by traversers
Method GetFail() As %List [ CodeMode = expression, Final ]
{
..FailNext
}

/// For use by optimizer
Method GetSuccTransparent(pMachine As Machine) As %List [ Final ]
{
	#Dim tI,tLink
	#Dim tSucc,tList As %List
	
	Set tSucc=..SuccNext
	If '..CanRemove(pMachine) {Quit $ListBuild(..ElementName)}
	
	Set tList=""
	Set tPtrI=0 While $ListNext(tSucc,tPtrI,tElemI) {
		Set tList=tList_pMachine.GetAt(tElemI).GetSuccTransparent(pMachine)
	}
	
	Quit tList
}

/// For use by optimizer
Method ReplaceSuccOrFail(pNext As %List, pIsSucc As %Boolean) [ Final ]
{
	#Dim tNextNoDups As %List
	
	Set tNextNoDups=..NoDups(pNext)
	
	If pIsSucc {
		Set ..SuccNext=tNextNoDups
	}
	Else {
		Set ..FailNext=tNextNoDups
	}
	
	Quit
}

ClassMethod NoDups(pList As %List) As %List
{
	#Dim tArr,tI,tName
	#Dim tOut As %List
	
	Kill tArr
	Set tPtrI=0 While $ListNext(pList,tPtrI,tElemI) {
		Set tArr(tElemI)=""
	}
	Set tOut=""
	Set tName="" While 1 {
		Set tName=$Order(tArr(tName)) If tName="" {Quit}
		Set tOut=tOut_$ListBuild(tName)
	}
	Quit tOut
}

/// Use Graphviz to draw a graph representing the NFA
ClassMethod Digraph(pMachine As Machine, pConfig As Config, pGraphName As %String = "nfa") As %Status
{
	#Dim tName,tId,tI,tTargetName,tTargetDescr,tEdgeLabel,tEdgeColor,tBoth
	#Dim tDigraph As %CPT.Tree.SimpleDigraph
	#Dim tElement As ElementBase
	#Dim tSC As %Status
	
	Set tDigraph=##class(%CPT.Tree.SimpleDigraph).%New(pGraphName)
	Set tName="" While 1 {
		Set tName=pMachine.Next(tName) If tName="" {Quit}
		Set tElement=pMachine.GetAt(tName)
		Set tId=..DigraphLabel(tName,tElement.Provenance,tElement.ShowContextVar())
		Set tSC=tDigraph.AddNode(tId,,tElement.DigraphColor()) If $$$ISERR(tSC) {Return tSC}
		Set tPtrI=0 While $ListNext(tElement.SuccNext,tPtrI,tElemI) {
			Set tTargetName=tElemI
			Set tTargetDescr=..DigraphLabel(tTargetName,pMachine.GetAt(tTargetName).Provenance,pMachine.GetAt(tTargetName).ShowContextVar())
			If $ListFind(tElement.FailNext,tTargetName) {
				Set $ListBuild(tEdgeLabel,tEdgeColor)=$ListBuild("BOTH","blue")
				Set tBoth(tTargetName)=""
			}
			Else {
				Set $ListBuild(tEdgeLabel,tEdgeColor)=$Select(tElement.FailNext="":$ListBuild("NEXT","blue"),1:$ListBuild("SUCC","green"))
			}
			Set tSC=tDigraph.AddEdge(tId,tTargetDescr,tEdgeLabel,tEdgeColor) If $$$ISERR(tSC) {Return tSC}
		}
		Set tPtrI=0 While $ListNext(tElement.FailNext,tPtrI,tElemI) {
			Set tTargetName=tElemI
			If '$Data(tBoth(tTargetName)) {
				Set tTargetDescr=..DigraphLabel(tTargetName,pMachine.GetAt(tTargetName).Provenance,pMachine.GetAt(tTargetName).ShowContextVar())
				Set tSC=tDigraph.AddEdge(tId,tTargetDescr,"FAIL","red") If $$$ISERR(tSC) {Return tSC}
			}
		}
	}
	
	Do ##class(Common).ShowDigraph(tDigraph,pGraphName,pConfig)
	
	Quit $$$OK
}

ClassMethod DigraphLabel(pName As %String, pProvenance As %List, pDecoration As %String) [ CodeMode = expression, Private ]
{
pName_pDecoration_$Char(10)_$ListLength(pProvenance)_$Select(..#GRAPHPROVENANCE:$Char(10)_$ListToString(pProvenance,$Char(10)),1:"")
}

Method Show() As %String [ CodeMode = expression, Final ]
{
"Element "_..ElementName_..ShowSourceOffset()_..ShowContextVar()_"|"_..Depth()_"["_##class(%XSQL.Format).ListFormat(..SuccNext)_", "_##class(%XSQL.Format).ListFormat(..FailNext)_"]"
}

Method GetProvenance() As %List [ CodeMode = expression, Final ]
{
..Provenance
}

Method GetSourceOffset() As %List [ CodeMode = expression, Final ]
{
..SourceOffset
}

Method ShowContextVar() As %String [ Final, Private ]
{
	#Dim tContextVar
	
	Set tContextVar=..GetContextVar()
	Quit $Select(tContextVar="":"",1:"["_tContextVar_"]")
}

Method ShowSourceOffset() As %String [ Final ]
{
	Quit "<"_$Select(..SourceOffset="":"",1:$ListToString(..SourceOffset))_"> "
}

}
