/* Copyright (c) 2020 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */

/// Adapter that handles internal service requests by acting as a SOAP client to an external SOAP server.
Class EnsLib.SOAP.OutboundAdapter Extends Ens.OutboundAdapter [ ClassType = "", ProcedureBlock, System = 4 ]
{

/// Declares the live URL target location for the WebService to be invoked. If not given, the default location declared in the WebService Client class will be used. <p/>
/// Note that SSL will only work if the URL starts with the https:// protocol prefix.
Property WebServiceURL As %String(MAXLEN = 1000) [ InitialExpression = "<default>" ];

/// Names the Client Class that describes the WebService, generated by the SOAP Client Wizard add-in
Property WebServiceClientClass As %String(MAXLEN = 1000);

/// Names the Credentials entry containing the Username and Password values to be used for WSSecurityLogin basic authentication if needed to access the SOAP service
Property SOAPCredentials As %String;

/// Names the Credentials entry containing the Username and Password values used to make the HTTP connection to the SOAP server
Property Credentials As %String;

/// The name of an existing SSL/TLS system configuration set to use (Secure Socket Layer / Transport Layer Security, configured via the system portal's Security Management page)
/// Note that for this setting to take effect you must ensure that https:// is used in WebServiceURL or in the default location declared
/// in the WebService Client class
Property SSLConfig As %String;

/// When making an SSL connection check the server identity in the certificate matches the name of the system we are connecting to.
/// This defaults to being on and matches based on the rules layed out in section 3.1 of RFC 2818.
Property SSLCheckServerIdentity As %Boolean [ InitialExpression = 1 ];

/// Proxy server through which to send HTTP requests, if any
Property ProxyServer As %String(MAXLEN = 1000);

/// Proxy server port on which to send HTTP requests if using a proxy server
Property ProxyPort As %Integer [ InitialExpression = 80 ];

/// Should the proxy (if any) use HTTPS to communicate with the real HTTP/HTTPS server?
Property ProxyHTTPS As %Boolean;

/// Should the Adapter use the HTTP CONNECT command to establish a tunnel through the proxy to the target HTTP server?
Property ProxyHttpTunnel As %Boolean;

/// Should the Adapter use a proxy SSL connection to the proxy (if any)?
/// Note: the use of SSL to the eventual endpoint is determined by the protocol part of web service's location url.
Property ProxyHttpSSLConnect As %Boolean;

/// Number of seconds to wait on each connection attempt
Property ConnectTimeout As %Numeric(MINVAL = 0) [ InitialExpression = 5 ];

/// Timeout for getting a response from the remote SOAP server (the timeout for opening the connection to the server is always 5 seconds). Setting the timeout to -1 means wait forever.
Property ResponseTimeout As %Numeric(MINVAL = -1) [ InitialExpression = 30 ];

// Number of seconds to wait for each successive incoming TCP read following receipt of initial response data from remote SOAP server

// Property ReadTimeout As %Numeric(MAXVAL = 600, MINVAL = 0) [ InitialExpression = 5 ];

/// The HTTP version the Adapter should report in the HTTP request it sends to the server
Property HttpVersion As %String [ InitialExpression = "1.1" ];

Parameter SETTINGS = "RegistryID:Basic:selector?context={Ens.ServiceRegistry.External.ContextSearch/Services?Protocols_1=SOAP},WebServiceURL:Basic,WebServiceClientClass:Basic,SOAPCredentials:Basic:credentialsSelector,Credentials:Basic:credentialsSelector,SSLConfig:Connection:sslConfigSelector,SSLCheckServerIdentity:Connection,ProxyServer:Proxy,ProxyPort:Proxy,ProxyHTTPS:Proxy,ProxyHttpTunnel:Proxy,ProxyHttpSSLConnect:Proxy,ConnectTimeout:Connection,ResponseTimeout:Connection,WriteTimeout:Connection";

/// Private instance of the WebServiceClientClass
Property %Client As %SOAP.WebClient;

/// Contains the WSSecurityLogin values to be used if needed to access the SOAP service
/// (Parallels the %CredentialsObj property inherited from Ens.Adapter)
Property %SOAPCredentialsObj As Ens.Config.Credentials;

/// Set this to the timeout to use when writing to the remote HTTP server.<br>
/// The default of -1 means it will wait indefinitely for the remote server to accept the
/// written data, change it to another value to specify the timeout in seconds.
Property WriteTimeout As %Numeric(MINVAL = -1) [ InitialExpression = -1 ];

/// Returns a web method proxy descriptor instance that represents the named method of the SOAP service designated by the WebServiceClientClass setting.
Method WebMethod(pMethodName As %String) As %SOAP.ProxyDescriptor [ CodeMode = expression ]
{
$S($IsObject(..%Client):..%Client.WebMethod(pMethodName),1:$$$NULLOREF)
}

/// Invoke a SOAP action by posting the whole body -- note that this will only work if the client class is %SOAP.WebRequest
Method InvokeWithSOAPBody(pAction As %String, pOneWay As %Boolean = 0, pRequest As %CharacterStream, ByRef pResponse As %CharacterStream) As %Status
{
	#dim tSC As %Status = $$$OK
	Quit:'$IsObject(..%Client)||(""=..%Client.Location) $$$ERROR($$$EnsErrGeneral,"Cannot invoke action "_pAction_"; WebServiceClientClass '"_..WebServiceClientClass_"' could not be not instantiated, or the WebServiceURL Location could not be determined")
	Quit:'..%Client.%IsA("%SOAP.WebRequest") $$$ERROR($$$EnsErrGeneral,"Cannot invoke action "_pAction_" unless '"_..WebServiceClientClass_"' IsA %SOAP.WebRequest")
	If '$IsObject(..%SOAPCredentialsObj) Do ..SOAPCredentialsSet(..SOAPCredentials) Quit:'$IsObject(..%SOAPCredentialsObj) $$$ERROR($$$EnsErrNoCredentials,..SOAPCredentials)
	Do:(""'=..%SOAPCredentialsObj.Username)&&(""=..%Client.SessionCookie) ..%Client.WSSecurityLogin(..%SOAPCredentialsObj.Username,..%SOAPCredentialsObj.Password)
	Set ..%Client.SSLConfiguration=..SSLConfig
	Set ..%Client.SSLCheckServerIdentity=..SSLCheckServerIdentity
	If ""'=..SSLConfig&&("https://"'=$ZCVT($E(..%Client.Location,1,$L("https://")),"L")) $$$LOGWARNING("SSLConfig '"_..SSLConfig_"' not in effect because https is not used in location '"_..%Client.Location_"'")

	#; Include supersession if appropriate
	Set tSC = ..SetSuperSessionHeader()
	If $$$ISERR(tSC) Quit tSC

	Kill %objlasterror  Set $ZT="SOAPTrap"

	// Delegate to %SOAP.WebRequest
	Set tSC = ..%Client.SendSOAPBody(pAction,pOneWay,pRequest,.pResponse)
Exit
	Do ..%Client.ResetHttpHeaders()
	#;Any errors are reported through the SOAPTrap and tSC set there
	Quit tSC
SOAPTrap
	#dim tZE As %String
	Set $ZT=""
	If ""'=$Get(%objlasterror) { Set tSC=%objlasterror }
	Else { Set tZE=$ZE,tSC=$$$ERROR($$$GeneralError,$g(tZE)) }

	Set:$$$ISERR(tSC)&&..isRetryable(tSC) ..BusinessHost.Retry = 1
	Goto Exit
}

/// Invoke a web method defined in the designated WebServiceClientClass on the SOAP server designated by the WebServiceURL setting
Method InvokeMethod(pMethodName As %String, Output pResult As %RegisteredObject, pArgs...) As %Status
{
	#dim tSC As %Status = $$$OK
	Kill pResult  Set pResult=$$$NULLOREF
	Quit:'$IsObject(..%Client)||(""=..%Client.Location) $$$ERROR($$$EnsErrGeneral,"Cannot invoke method "_pMethodName_"; WebServiceClientClass '"_..WebServiceClientClass_"' could not be instantiated, or the WebServiceURL Location could not be determined")
	If '$IsObject(..%SOAPCredentialsObj) Do ..SOAPCredentialsSet(..SOAPCredentials) Quit:'$IsObject(..%SOAPCredentialsObj) $$$ERROR($$$EnsErrNoCredentials,..SOAPCredentials)
	Do:(""'=..%SOAPCredentialsObj.Username)&&(""=..%Client.SessionCookie) ..%Client.WSSecurityLogin(..%SOAPCredentialsObj.Username,..%SOAPCredentialsObj.Password)
	Set ..%Client.SSLConfiguration=..SSLConfig
	Set ..%Client.SSLCheckServerIdentity=..SSLCheckServerIdentity
	If ""'=..SSLConfig&&("https://"'=$ZCVT($E(..%Client.Location,1,$L("https://")),"L")) $$$LOGWARNING("SSLConfig '"_..SSLConfig_"' not in effect because https is not used in location '"_..%Client.Location_"'")

	#; Include supersession if appropriate
	Set tSC = ..SetSuperSessionHeader()
	If $$$ISERR(tSC) Quit tSC

	Kill %objlasterror  Set $ZT="SOAPTrap"
	// Up to 252 args...  (254 signature limit less 2 for method invocation - oref, method).
	If ""=$$$GetClassParameter($classname(..%Client)_"."_pMethodName,"XMLRESULTNAME") {
		Do $method(..%Client,pMethodName,pArgs...)
		$$$sysTRACE("After invoke of method "_pMethodName_" with "_$G(pArgs,0)_" args and no retval")
	} Else {
		Set pResult = $method(..%Client,pMethodName,pArgs...)
		$$$sysTRACE("Got Result "_pResult_" from invoke of method "_pMethodName_" with "_$G(pArgs,0)_" args")
	}
	#;Any errors are reported through the SOAPTrap and tSC set there
	Set tSC = $$$OK
Exit
	Do ..%Client.ResetHttpHeaders()
	Quit tSC
SOAPTrap
	Set $ZT=""
	If ""'=$Get(%objlasterror) { Set tSC=%objlasterror }
	Else { Set tZE=$ZE,tSC=$$$ERROR($$$GeneralError,$g(tZE)) }

	Set:$$$ISERR(tSC)&&..isRetryable(tSC) ..BusinessHost.Retry = 1
	Goto Exit
}

/// Invoke a web method defined in the designated WebServiceClientClass on the SOAP server designated by the WebServiceURL setting.
/// The pWebMethod argument is a SOAP client ProxyDescriptor object that you may obtain by calling ..Adapter.WebMethod(pMethodName).
/// You may then set all the input argument properties of the object before calling this method and obtain the result from the object's %Result property.
/// Using this method instead of InvokeMethod() saves the overhead of several layers of function calls.
/// Note that nearly equivalent functionality is obtainable using the InvokeMethod() method by adding Parameter ARGUMENTSTYLE="message" to the class definition of the SOAP client class designated in the WebServiceClientClass setting.
/// The SOAP Client Wizard will add this parameter to the client class it constructs if you check the box labeled "Use unwrapped message format for document style WebMethods".
Method Invoke(pWebMethod As %SOAP.ProxyDescriptor) As %Status
{
	#dim tSC As %Status = $$$OK
	$$$ASSERT($$$IsdefObject(pWebMethod) && ($classname(pWebMethod)[..WebServiceClientClass_"."))
	Quit:'$IsObject(..%Client)||(""=..%Client.Location) $$$ERROR($$$EnsErrGeneral,"Cannot invoke "_$classname(pWebMethod)_"(); WebServiceClientClass '"_..WebServiceClientClass_"' could not be not instantiated, or the WebServiceURL Location could not be determined")
	$$$sysTRACE($classname(pWebMethod)_"()")

	If '$IsObject(..%SOAPCredentialsObj) Do ..SOAPCredentialsSet(..SOAPCredentials) Quit:'$IsObject(..%SOAPCredentialsObj) $$$ERROR($$$EnsErrNoCredentials,..SOAPCredentials)
	Do:(""'=..%SOAPCredentialsObj.Username)&&(""=..%Client.SessionCookie) ..%Client.WSSecurityLogin(..%SOAPCredentialsObj.Username,..%SOAPCredentialsObj.Password)
	Set ..%Client.SSLConfiguration=..SSLConfig
	Set ..%Client.SSLCheckServerIdentity=..SSLCheckServerIdentity
	If ""'=..SSLConfig&&("https://"'=$ZCVT($E(..%Client.Location,1,$L("https://")),"L")) $$$LOGWARNING("SSLConfig '"_..SSLConfig_"' not in effect because https is not used in location '"_..%Client.Location_"'")

	#; Include supersession if appropriate
	Set tSC = ..SetSuperSessionHeader()
	If $$$ISERR(tSC) Quit tSC

	Kill %objlasterror  Set $ZT="SOAPTrap"

	Set tOneWay = pWebMethod.%GetParameter("SOAPONEWAY")
	Do ..%Client.InvokeClient(pWebMethod,pWebMethod.%RequestName,..getAction(pWebMethod,..WebServiceClientClass),tOneWay)
	$$$sysTRACE("Got Result "_$S(tOneWay:"",1:pWebMethod.%Result))
	#;Any errors are reported through the SOAPTrap and tSC set there
	Set tSC = $$$OK
Exit
	Do ..%Client.ResetHttpHeaders()
	Quit tSC
SOAPTrap
	Set $ZT=""
	If ""'=$Get(%objlasterror) { Set tSC=%objlasterror }
	Else { Set tZE=$ZE,tSC=$$$ERROR($$$GeneralError,$g(tZE)) }

	Set:$$$ISERR(tSC)&&..isRetryable(tSC) ..BusinessHost.Retry = 1
	Goto Exit
}

Method isRetryable(pSC As %Status) As %Boolean [ CodeMode = expression, Internal ]
{
$$$StatusEquals(pSC,$$$HttpRequestConnect,$$$SOAPUnexpectedStatus,$$$CSPTimeout)
}

ClassMethod getAction(pWebMethod As %SOAP.ProxyDescriptor, pClientClassname As %String) As %String [ Internal ]
{
	Set tAction = pWebMethod.%GetParameter("ACTION")
	If ""=tAction {
		#; If the proxy parameter is missing, get it from the Client class
		Set method = pWebMethod.%ClassName()
		
		#; Find the Operation argument to the WebMethod call and the Action argument to the Invoke() call
		Set tAction="" For i=1:1:$$$defMemberKeyGet(pClientClassname,$$$cCLASSmethod,method,$$$cMETHimplementation) {
			Set line=$$$defMemberArrayGet(pClientClassname,$$$cCLASSmethod,method,$$$cMETHimplementation,i)
			Set line=$TR(line," "_$C(9))
			Set tAction=$P($P(line,""").Invoke($this,""",2),""",")
			#;Set pOperation=$P($P(line,"..WebMethod(""",2),""")")
			Quit:""'=tAction
		}
	}
	Quit tAction
}

/// This method parallels the inherited CredentialsSet method used here for HTTP credentials.
Method SOAPCredentialsSet(pInVal As %String) As %Status [ Internal ]
{
	#; (Re)Set the Credentials object; do it always because we never know if the source row fields might have been updated
	#; make sure to instantiate even if re-setting to the InitialExpression string
	Set ..%SOAPCredentialsObj=$$$NULLOREF

	Set tClassname=$zobjmethod($this,"%ClassName",1) ; call subclass
	Set tClass = $$$comMemberKeyGet(tClassname,$$$cCLASSproperty,"%SOAPCredentialsObj",$$$cPROPtype)
	If ""'=tClass {
		Set tSC=##Class(Ens.Config.Credentials).GetCredentialsObj(.tObj,tClassname,tClass,pInVal)
		Set:$$$ISOK(tSC) ..%SOAPCredentialsObj=tObj
		If $$$ISOK(tSC) { Set ..%SOAPCredentialsObj=tObj }
		ElseIf '$$$StatusEquals(tSC,$$$EnsErrNoCallerCredentials) {
			$$$LOGSTATUS(tSC)
		}
	}
	Set i%SOAPCredentials=pInVal
	Quit $$$OK
}

Method CredentialsSet(pInVal As %String) As %Status [ Internal ]
{
	Set tSC=##super(pInVal) Quit:$$$ISERR(tSC) tSC
	Set:$IsObject(..%Client)&&$IsObject(..%CredentialsObj) ..%Client.HttpUsername=..%CredentialsObj.Username, ..%Client.HttpPassword=..%CredentialsObj.Password
	Quit $$$OK
}

Method SSLConfigSet(pInVal As %String) As %Status [ Internal ]
{
	Set i%SSLConfig=pInVal
	Set:$IsObject(..%Client) ..%Client.SSLConfiguration=pInVal
	Quit $$$OK
}

Method ProxyServerSet(pInVal As %String) As %Status [ Internal ]
{
	Set i%ProxyServer=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpProxyServer=pInVal
	Quit $$$OK
}

Method ProxyPortSet(pInVal As %String) As %Status [ Internal ]
{
	Set i%ProxyPort=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpProxyPort=pInVal
	Quit $$$OK
}

Method ProxyHTTPSSet(pInVal As %Boolean) As %Status [ Internal ]
{
	Set i%ProxyHTTPS=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpProxyHTTPS=pInVal
	Quit $$$OK
}

Method ConnectTimeoutSet(pInVal As %Boolean) As %Status [ Internal ]
{
	Set i%ConnectTimeout=pInVal
	Set:$IsObject(..%Client) ..%Client.OpenTimeout=$S(pInVal=-1:2123456789,1:pInVal)
	Quit $$$OK
}

Method ResponseTimeoutSet(pInVal As %Boolean) As %Status [ Internal ]
{
	Set i%ResponseTimeout=pInVal
	Set:$IsObject(..%Client) ..%Client.Timeout=$S(pInVal=-1:2123456789,1:pInVal)
	Quit $$$OK
}

Method ProxyHttpTunnelSet(pInVal As %Boolean) As %Status [ Internal ]
{
	Set i%ProxyHttpTunnel=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpProxyTunnel=pInVal
	Quit $$$OK
}

Method ProxyHttpSSLConnectSet(pInVal As %Boolean) As %Status [ Internal ]
{
	Set i%ProxyHttpSSLConnect=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpProxySSLConnect=pInVal
	Quit $$$OK
}

Method HttpVersionSet(pInVal As %Boolean) As %Status [ Internal ]
{
	Set i%HttpVersion=pInVal
	Set:$IsObject(..%Client) ..%Client.HTTPVersion=pInVal
	Quit $$$OK
}

Method WebServiceURLSet(pInVal As %String) As %Status [ Internal ]
{
	Set i%WebServiceURL=pInVal
	Set:$IsObject(..%Client) ..%Client.Location=$S($Case($ZCVT(pInVal,"L"),"":0, "<default>":0, "default":0,:1):pInVal, 1:$$$GetClassParameter(..WebServiceClientClass,"LOCATION"))
	Quit $$$OK
}

Method WriteTimeoutSet(pInVal As %String) As %Status [ Internal ]
{
	Set i%WriteTimeout=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpWriteTimeout=pInVal
	Quit $$$OK
}

Method WebServiceClientClassSet(pInVal As %String) As %Status [ Internal ]
{
	Set i%WebServiceClientClass=pInVal
	If ""=pInVal Set ..%Client=$$$NULLOREF  Quit $$$OK
	Kill %objlasterror  Set $ZT="NewTrap"
	Set ..%Client=$zobjclassmethod(pInVal,"%New")
	Set $ZT=""
AfterNew
	If $IsObject(..%Client) {
		If ..%Client.%Extends("%SOAP.WebClient") {
			Set ..%Client.Location=$S($Case($ZCVT(..WebServiceURL,"L"),"":0, "<default>":0, "default":0,:1):..WebServiceURL, 1:$$$GetClassParameter(pInVal,"LOCATION"))
			Set:$IsObject(..%CredentialsObj) ..%Client.HttpUsername=..%CredentialsObj.Username, ..%Client.HttpPassword=..%CredentialsObj.Password
			Set ..%Client.HttpProxyServer=..ProxyServer, ..%Client.HttpProxyPort=..ProxyPort, ..%Client.HttpProxyHTTPS=..ProxyHTTPS, ..%Client.OpenTimeout=$S(..ConnectTimeout=-1:2123456789,1:..ConnectTimeout), ..%Client.Timeout=$S(..ResponseTimeout=-1:2123456789,1:..ResponseTimeout), ..%Client.HttpProxyTunnel=..ProxyHttpTunnel, ..%Client.HttpProxySSLConnect=..ProxyHttpSSLConnect, ..%Client.HTTPVersion=..HttpVersion
			Set ..%Client.HttpWriteTimeout=..WriteTimeout
		} Else {
			$$$LOGERROR("WebService Client class "_pInVal_" must be a SOAP client proxy class derived from %SOAP.WebClient")
			Set ..%Client=$$$NULLOREF
		}
	} Else {
		$$$LOGERROR("Failed to instantiate WebClient class "_pInVal_" : "_$$$StatusDisplayString(%objlasterror))
	}
	Quit $$$OK
NewTrap
	Set $ZT=""
	Set ..%Client=$$$NULLOREF
	If ""=$Get(%objlasterror) Set tZE=$ZE,%objlasterror=$$$ERROR($$$GeneralError,$g(tZE))
	GoTo AfterNew
}

/// Return a human-readable target address for use in Trace messages
Method GetAddress() As %String [ CodeMode = expression, Internal ]
{
..%Client.Location_$S(""=..ProxyServer:"",1:" via "_..ProxyServer_":"_..ProxyPort)
}

/// Insert Super Session into header if appropriate
Method SetSuperSessionHeader() As %Status
{
	#dim tSC As %Status = $$$OK
	If ..BusinessHost.IncludeSuperSession(.tSC) {
		Do ..%Client.SetHttpHeader($$$EnsHTTPHeaderSuperSession,..BusinessHost.%SuperSession)
	}
	Quit tSC
}

}
